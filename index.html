<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Building a Little Cluster</title>
        <meta name="description" content="a guide to setting up a raspberry pi cluster">
        <link rel="stylesheet" href="css/main.css">
    </head>
    <body>
          <img src="images/walogo.png"/>

          <h1>Raspberry Pi Cluster Setup</h1>

          <ul>
            <li><a href="#intro">Setting up a Raspberry Pi Cluster</a></li>
            <li><a href="#command">Command Terminals</a></li>
            <li><a href="#materials">Materials</a></li>
            <li><a href="#connections">Connecting the Pis</a></li>
            <li><a href="#mainnode">Setting Up the Main Node</a></li>
            <li><a href="#workers">Setting up the worker nodes</a></li>
            <li><a href="#bench">A Quick Benchmark</a></li>
            <li><a href="https://www.epcc.ed.ac.uk/discover-and-learn/resources-and-activities/what-is-a-supercomputer/wee-archie">Wee Archie</a></li>
            <!--TODO Add link to command glossary which I am going to make-->
            <!--<li>Glossary of commands</li>-->
          </ul>

          <h2>Version and Authorship</h2>
          <table>
            <tr><td><b>Version</b></td><td>0.96</td></tr>
            <tr><td><b>Author</b></td><td>A Grant (EPCC)</td></tr>
            <tr><td><b>Contributors</b></td><td>M Antonioletti (EPCC), O T Brown (EPCC), J Kennedy (EPCC), G Gibb (EPCC),  R MacLeod (EPCC)</td></tr>
            <tr><td><b>Notes</b></td><td>Linux Network Connection to be completed. </td></tr>
            <tr><td><b>Notes</b></td><td>Raspbian SSH Access Note added. </td></tr>
          </table>

          <a name="intro"><h2>Before You Start</h2></a>

          <p>These instructions will help you set up a small cluster of Raspberry Pi computers as a small parallel system. They will take you through the process of connecting the Pis together, setting up the environment and checking that it works correctly.
          </p>
          <p>
            These instructions are not for complete beginners with computers - they assume knowledge of concepts such as networks, command line and file systems. There are some explanations in this document but still require some experience and a willingness to try things out.
          </p>
          <p>
            <b>Note:</b> these instructions deal with a cluster of 5 Raspberry Pis but the cluster can be of any size you want (minimum of 2, as otherwise it is not a parallel computer!)
          </p>
           <p>
             <b>Note:</b> Raspbian refers to the version of Linux commonly distributed with the Raspberry Pi computers. New Out Of Box Software (NOOBS) is an easy-to-use installation manager for Raspian which you can use if you're setting up your Pis for the first time.
           </p>
          <p>
            <b>Note:</b>If you try these instructions and find any issues or have suggestions, please submit an issue to <a href="https://github.com/EPCCed/wee_archlet/issues">our GitHub repo</a>.
          </p>
          <a name="command"><h3>Command Terminals</h3></a>
          <p>
            This document will refer to command terminals throughout, when accessing, configuring, and controlling the Raspberry Pis from your computer. A command terminal provides a textual interface to a user, rather than a graphical interface that you might be more used to. Command line interfaces often look like:
            <figure>
              <img src="images/terminal.png" alt="Terminal"/>
              <figcaption>Example Terminal</figcaption>
            </figure>
            Sometimes they will have light text on a dark background - you can configure them to your own liking. Regardless, a Raspberry Pi uses the Linux operating system and will have a terminal that functions and behaves in the same way this document describes.
          </p>
          <p>
            On a Linux system, you will need to open a command terminal on your computer - you may be able to get this using a right mouse click and choosing "Terminal", or from a list of programs in the program menu.
          </p>
          <p>
            On Windows 10 you can use PowerShell, which you can find through the search feature in the taskbar. If you prefer, you can install a Secure Shell (SSH) client to connect to the Raspberry Pis. Two free options are: - <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</a>, and <a href="https://mobaxterm.mobatek.net/">MobaXterm</a>. These instructions assume that you are working from the command line, so if you are using an SSH client please check its documentation so you know how it works.
          </p>
          <p>
            On a Mac OS machine, Terminal is under Utilities in the Applications folder.
          </p>

          <a name="materials"><h2>Materials</h2></a>
          <h3>You will need:</h3>
          <ul>
            <li>5 Raspberry Pis (Note the examples used in these instructions are Raspberry Pi 3s - the instructions should work for most Raspberry Pi models - if problems are encountered please submit an issue to <a href="https://github.com/EPCCed/wee_archlet/issues">Cluster Instructions</a>).</li>
            <li>5 Power Supplies/1 Multisupply Unit.</li>
            <li>1 Switch (with at least 8 Ports).</li>
            <li>6 Ethernet Cables.</li>
            <li>5 Power cables. </li>
            <li>Laptop or desktop PC with a shareable ethernet connection.</li>
          </ul>

          <h3>Optionally:</h3>
          <ul>
            <li>5 Raspberry Pi cases - we've used <a href="http://cpc.farnell.com/multicomp/cbpiblox-red/pi-blox-enclosure-red-rev3/dp/SC14019">Lego-Style cases</a>, which are stackable.</li>
          </ul>

          <h3>Suitable and Unsuitable Raspberry Pi Models</h3>
          <p>
            <b>NOTE:</b>There are many products with the Raspberry Pi name so this is a list of the ones that are suitable and unsuitable for these instructions.
          </p>
          <p>
            Suitable Raspberry Pi Models (these instructions work for these types of Raspberry Pi):
          </p>
          <ul>
            <li>Raspberry Pi 3</li>
            <li>Raspberry Pi 2</li>
          </ul>
          <p>
            Unsuitable Raspberry Pi Models (these instruction will not work or require substantial changes and/or additional hardware):
          </p>
          <ul>
            <li>Raspberry Pi Zero</li>
            <li>Raspberry Pi Zero W</li>
            <li>Raspberry Pi Compute Module</li>
          </ul>

          <p>
            At the time of writing there are three types of  Raspberry Pi in the market - to distinguish between them we provide the following images:
          </p>
          <figure>
            <img src="images/11546-04.jpg" alt="Raspberry Pi 1"/>
            <figcaption>Raspberry Pi 1 Model B</figcaption>
          </figure>
          <figure>
            <img src="images/Raspberry-Pi-2-Bare-BR.jpg" alt="Raspberry Pi 2"/>
            <figcaption>Raspberry Pi 2 Model B</figcaption>
          </figure>
          <figure>
            <img src="images/Raspberry_Pi_3_Model_B.png" alt="Raspberry Pi 3"/>
            <figcaption>Raspberry Pi 3 Model B</figcaption>
          </figure>

          <p>
            If you are using cases - this is the point where you should put the Raspberry Pi into its case. An example of a cased Raspberry Pi would look like this:
          </p>
          <figure>
            <img src="images/IMG_20160906_105359475.jpg" alt="Cased Raspberry Pi Open"/>
            <figcaption>Lego Style Case - Open</figcaption>
          </figure>
          <figure>
            <img src="images/IMG_20160906_105327393.jpg" alt="Cased Raspberry Pi Closed"/>
            <figcaption>Lego Style Case - Closed</figcaption>
          </figure>

          <h3>Materials used in these instructions:</h3>
          <p>
            We've used Raspberry Pi 3s for our cluster. In place of 5 mains power supplies, we've chosen <a href="http://www.farnell.com/datasheets/1948264.pdf">1 Multi-USB Power Socket. Note - This particular model appears to have been discontinued</a>. Each pi is connected to this via a USB to B-type Micro USB cable. Our switch is a Netgear GS108E.
          </p>

          <h3>Important Note for New Raspbian Installations</h3>
          <p>
            Due to changes in the recent versions of Raspbian and the NOOBS distributions, to follow these instructions you have to make a change to your Raspberry Pi SD Card before you boot it up for the first time.
          </p>
          <p>
            Newer versions of Raspbian have SSH access disabled by default. To reenable it, you will need to insert the microSD cards containing Raspbian into your computer and create a blank text file called 'SSH' in the boot partition. This will be the disk that appears in your file system when you insert the microSD card.
          </p>
          <p>
            Once you have created the file, you will be able to boot Raspbian with SSH remote access enabled.
          </p>

          <h2><a name="connections">Connecting the Raspberry Pi Cluster</a></h2>
          <ol>
            <li>Connect the Ethernet Cables to the ethernet ports:</li>

            <figure>
              <img src="images/IMG_20170210_132818620.jpg" alt="Ether Pi"/>
              <figcaption>Connect Ethernet to Pi</figcaption>
            </figure>

            <li>Connect the ethernet cables to the switch:</li>

            <figure>
              <img src="images/IMG_20170210_132909899.jpg" alt="Ether Switch"/>
              <figcaption>Connect Ethernet to Switch</figcaption>
            </figure>

            Now it should look something like:
            <figure>
              <img src="images/IMG_20170210_132914225.jpg" alt="Ethernet"/>
              <figcaption>Connected</figcaption>
            </figure>

            <li>Connect your laptop or desktop to the switch via an ethernet cable. (Note that while Raspberry Pi 3 has a built-in wireless network - we are not using this and at this point it probably would not have been set up.)</li>

            <li>Now all the network cables are connected - we need to put the power cables in. First connect the power cable for the switch and turn it on:</li>

            <figure>
              <img src="images/IMG_20170210_132948565.jpg" alt="Ethernet"/>
              <figcaption>Switch Power</figcaption>
            </figure>

            <li>Now connect each of the Raspberry Pis to your power supply and turn them on. In this case we are using an externally powered USB-hub:</li>

            <figure>
              <img src="images/IMG_20170210_133056149.jpg" alt="Ethernet"/>
              <figcaption>Raspberry Pi Power</figcaption>
            </figure>

            <figure>
              <img src="images/IMG_20170210_133126552_HDR.jpg" alt="Ethernet"/>
              <figcaption>Plug in</figcaption>
            </figure>

            And that's it! All the Pi units should have LED lights on or flashing, and look something like this:

            <figure>
              <img src="images/IMG_20170210_133145864.jpg" alt="Ethernet"/>
              <figcaption>Our Cluster</figcaption>
            </figure>

          </ol>

          <h2><a name="sharing">Network Software Setup</a></h2>

          <p>
            <b>Note: </b>These instructions assume you are using a computer connected to the internet via Wi-Fi.
          </p>
          <p>
            First on your laptop/desktop you will have to configure the internet sharing, so that the Raspberry Pi's can connect to the Wifi via an ethernet connection to your laptop or desktop. How you do this depends on your operating system:
          </p>

          <h3>OS X (Mac OS)</h3>
          <ol>
            <li>Go to System Perferences and choose 'Sharing'.</li>

            <figure>
              <img src="images/mac-preferences.png" alt="Mac preferences"/>
              <figcaption>Mac preferences</figcaption>
            </figure>

            <li>Click on Internet Sharing and choose share from Wifi to Ethernet.</li>
          </ol>

          <h3>Windows 10</h3>
          <ol>
            <li>Go into 'Network and Sharing Centre' in the Control Panel</li>
            <li>Choose 'Change adapter options' from the options on the left, and right-click on the Wi-Fi connection (identifiable by a signal strength indicator in the icon, wired networks will not have this). Select 'Properties' from the menu.</li>
            <li>Select the Sharing Tab, and from there check the box at "Allow other network users to connect through this computer's Internet Connection.</li>
            <li>Ensure that the Home networking connection is your Ethernet network in the drop-down menu below.</li>
            <li>Close the Wi-Fi Properties window to return to the Network Connections. Right-click on the Ethernet connections and select 'Properties' again you have just done for Wi-Fi.</li>
            <li>In the list headed "This connection uses the following items", click on the one called "Internet Protocal Version 4". This will enable a 'Properties' button just below, click on this.</li>
            <li>Take a note of the IP Address and Subnet Mask listed. You can now close down all the windows you've opened.</li>
          </ol>

          <h3>Linux</h3>
          <h4>Ubuntu</h4>
          <ol>
            <li>Open a terminal and run the command <pre>nm-connection-editor</pre> to open the network connection editor.</li>
            <li>Select your internet connection, then click the cog icon to edit the connection settings.
              <figure>
                <img src="images/ubuntu_nm-connection-editor.png" alt="nm-connection-editor"/>
                <figcaption>Edit network connection (note that this screenshot was taken on a virtual machine and so shows a Wired Connection, not Wi-Fi, which is what you should be using).</figcaption>
              </figure>
              <li>Go to the "IPv4 Settings" tab and select "Shared to other computers" from the "Method" drop-down list</li>
              <li>Click "Save", and close the connection editor</li>
            </ol>

            <h2>Getting into the Pi</h2>
            <p>
              The next step is to obtain the IP addresses for each Raspberry Pi in your cluster. Again, how you do this will depend on what operating system you use.
            </p>
            <p>
              IP addresses are what we can use to identify a Pi on the network and use it as a target to log in - its the same as a street address when going somewhere - though IP addresses can change.

              A brief explanation of IP Addresses and DHCP are available at the following links:
            </p>

            <ul>
              <li><a href="https://en.wikipedia.org/wiki/IP_address">IP Address</a></li>
              <li><a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">DHCP</a></li>
            </ul>

            <h3>MacOS and Linux</h3>
            <p>
              For the setup used here, the shared network connection showed up as an adapter called <code>bridge100</code> after running <code>ifconfig</code>. This is what allows the WiFi connection to be shared to the Ethernet connection.
            </p>
            <p>
              <b>Note:</b> Bridge100 may be using some other name on your computer, especially if you are using Linux. To check which interface is created - type <code>ifconfig</code> before turning on your sharing or plugging in your adapter then run it again afterwards to find out what difference the changes made.
            </p>
            <p>
              <b>Note:</b> On more recent versions of Linux (Ubuntu 18.04+) ifconfig is deprecated. Instead use:
              <pre>ip -c addr show</pre>
            </p>

            <ol>
              <li>Open a command terminal:</li>
              <figure>

                <img src="images/terminal.png" alt="Terminal"/>
                <figcaption>Example Terminal</figcaption>
              </figure>

              <li>
                Type: <code>ifconfig</code>. This should output something like:
                <pre>
  lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
  	options=3&lt;RXCSUM,TXCSUM&gt;
  	inet6 ::1 prefixlen 128
  	inet 127.0.0.1 netmask 0xff000000
  	inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1
  	nd6 options=1&lt;PERFORMNUD&gt;
  gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
  stf0: flags=0&lt;&gt; mtu 1280
  en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
  	ether a4:5e:60:e7:21:0f
  	inet6 fe80::a65e:60ff:fee7:210f%en0 prefixlen 64 scopeid 0x4
  	inet 172.20.152.14 netmask 0xfffff000 broadcast 172.20.159.255
  	nd6 options=1&lt;PERFORMNUD&gt;
  	media: autoselect
  	status: active
  en1: flags=963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX&gt; mtu 1500
  	options=60&lt;TSO4,TSO6&gt;
  	ether 6a:00:00:41:c6:f0
  	media: autoselect &lt;full-duplex&gt;
  	status: inactive
  en2: flags=963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX&gt; mtu 1500
  	options=60&lt;TSO4,TSO6&gt;
  	ether 6a:00:00:41:c6:f1
  	media: autoselect &lt;full-duplex&gt;
  	status: inactive
  bridge0: flags=8822&lt;BROADCAST,SMART,SIMPLEX,MULTICAST&gt; mtu 1500
  	options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt;
  	ether a6:5e:60:7e:1d:00
  	Configuration:
  		id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0
  		maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200
  		root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0
  		ipfilter disabled flags 0x2
  	member: en1 flags=3&lt;LEARNING,DISCOVER&gt;
  	        ifmaxaddr 0 port 5 priority 0 path cost 0
  	member: en2 flags=3&lt;LEARNING,DISCOVER&gt;
  	        ifmaxaddr 0 port 6 priority 0 path cost 0
  	media: &lt;unknown type&gt;
  	status: inactive
  p2p0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2304
  	ether 06:5e:60:e7:21:0f
  	media: autoselect
  	status: inactive
  awdl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1484
  	ether ca:90:43:20:19:ba
  	inet6 fe80::c890:43ff:fe20:19ba%awdl0 prefixlen 64 scopeid 0x9
  	nd6 options=1&lt;PERFORMNUD&gt;
  	media: autoselect
  	status: active
  vboxnet0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
  	ether 0a:00:27:00:00:00
  	inet 192.168.59.3 netmask 0xffffff00 broadcast 192.168.59.255
  vboxnet1: flags=8842&lt;BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
  	ether 0a:00:27:00:00:01
                </pre>

                You are most likely to be looking for the bridge100 interface:

                <pre>
  bridge100: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
  	options=3&lt;RXCSUM,TXCSUM&gt;
  	ether a6:5e:60:7e:1d:64
  	inet 192.168.2.1 netmask 0xffffff00 broadcast 192.168.2.255
  	inet6 fe80::a45e:60ff:fe7e:1d64%bridge100 prefixlen 64 scopeid 0xe
  	Configuration:
  		id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0
  		maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200
  		root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0
  		ipfilter disabled flags 0x2
  	member: en4 flags=3&lt;LEARNING,DISCOVER&gt;
  	        ifmaxaddr 0 port 10 priority 0 path cost 0
  	Address cache:
  	nd6 options=1&lt;PERFORMNUD&gt;
  	media: &lt;unknown type &gt;
  	status: inactive
                </pre>

                In this example, the IP address is 192.168.2.1 (line beginning with <code>inet</code> above.)
              </li>

              <li>
                There are two ways to find out what is connected. the first is to run the command <code>arp</code>:
                <pre>
  arp -i bridge100 -a
                </pre>

                This runs a program which returns information about what is connected currently to the <code>bridge100</code> interface. When you run this command you will get output which contains lines like:

                <pre>
  ? (239.255.255.250) at 1:0:5e:7f:ff:fa on bridge100 ifscope permanent [ethernet]
                </pre>

                Running the <code>arp</code> command will give you a list of connected IP addresses - there should be the same number of addresses as you have Raspberry Pis connected.
              </li>

              <li>
                The other way is to install a program like nmap, which is available from <a href="https://nmap.org/">https://nmap.org/</a>. You can run it in two ways (replacing the IP addresses with the one you noted when running <code>ifconfig</code>):
                <ul>
                  <li>Scan a range of IP addresses (use this option if you know what range your connection sharing will use): <pre> nmap 192.168.2.1-255</pre></li>
                  <li>Scan a subnet on the network (use this option if you only know the start of the IP address range, e.g 192.168.2): <pre>nmap 192.168.2.0/24</pre></li>
                </ul>
              </li>
            </ol>

            <h3> <a name="winnmap">Windows</a></h3>
            <p>
              The easiest way to determine the IP addresses on Windows is with nmap, which you can download from <a href="https://nmap.org/">here</a>.
            </p>

            <ol>
              <li>
                Using the Ethernet IP address you noted before when sharing the Internet Connection, run the following command, but change the last number to 0:
                <pre>
  c:\nmap 192.168.137.0/24
                </pre>

                This should give output like:

                <pre>
  Starting Nmap 7.40 ( https://nmap.org ) at 2017-04-26 15:53 GMT Daylight Time
  Nmap scan report for 192.168.137.225
  Host is up (0.00013s latency).
  All 1000 scanned ports on 192.168.137.225 are closed
  MAC Address: 98:5A:EB:C7:15:8B (Apple)

  Nmap scan report for 192.168.137.1
  Host is up (0.0013s latency).
  Not shown: 997 closed ports
  PORT    STATE SERVICE
  135/tcp open  msrpc
  139/tcp open  netbios-ssn
  445/tcp open  microsoft-ds

  Nmap done: 256 IP addresses (2 hosts up) scanned in 23.48 seconds

                  </pre>
                  All the IP addresses which show up starting with Nmap scan report for IP address will be your Raspberry Pis - except for the one with your written down IP address.
              </li>
            </ol>

            <a name="mainnode"><h2>Setting Up the Main Node</h2></a>
            <p>
              Now we have our Pis started, we know their current IP addresses, we can start doing some configuration and setup. In this guide, the Pi with address 192.168.2.18 the master node in the cluster, and the other Pis will be worker nodes. In our cluster, the master node will run the network assigning IP addresses via the DHCP server, share its Wifi connection (if used), share a networked drive for files, and start the programs we will run on the cluster.
            </p>
            <p>
              For example, my five Pi addresses are:
            </p>
            <pre>
  192.168.2.18
  192.168.2.19
  192.168.2.20
  192.168.2.21
  192.168.2.22
            </pre>

            <p>
              <b>Note:</b> These IP addresses are only valid with the current connection to your computer. After the setup is complete, the Raspberry Pis will be assigned addresses by the cluster server.
            </p>

            <h3>Logging in to the Master Node</h3>
            <p>
              In your command terminal type the following command, using the username (if not the default <code>pi</code>) and IP address for the Pi that will be your master node:
            </p>
            <pre>
  ssh pi@192.168.2.18
            </pre>

            <p>
              The first time you do this, the output will look something like this:
            </p>
            <pre>
  The authenticity of host '192.168.2.18 (192.168.2.18)' can't be established.
  RSA key fingerprint is a0:97:1f:d6:df:8c:a5:45:db:fe:b4:94:46:1d:0f:48.
  Are you sure you want to continue connecting (yes/no)?
            </pre>

            <p>
              Type <code>yes</code> to allow this and future connections:
            </p>
            <pre>
  Warning: Permanently added '192.168.2.18' (RSA) to the list of known hosts.
  pi@192.168.2.18's password:
            </pre>
            <p>
              Enter the password for that user (the default will be <code>raspberry</code>).
            </p>

            <p>
              If the password is correct, you will get the following output:
            </p>
            <pre>
  The programs included with the Debian GNU/Linux system are free software;
  the exact distribution terms for each program are described in the
  individual files in /usr/share/doc/*/copyright.


  Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
  permitted by applicable law.
  Last login: Fri Feb 26 03:25:51 2016
  pi@raspberrypi:~ $
            </pre>

            <p>
              You are now remotely logged in to that account on your Raspberry Pi, via your laptop/desktop. Any commands you enter while logged in will be executed as if you were doing so on the Pi directly. This is a standard way of logging into a remote system - like a supercomputer such as ARCHER.
            </p>

            <a name="configrpi"><h3>System Configuration</h3></a>
            <p>
              To open the Raspberry Pi confiuration program, enter the command <code>sudo raspi-config</code>:
            </p>
            <pre>
  pi@raspberrypi:~ $ sudo raspi-config
            </pre>
            <p>
              The <code>sudo</code> prefix means that the following commands will be run as the super-user which has permissions to make system-wide changes rather than just changes to user files.
            </p>

            <p>
              This will bring up a menu. Select the following options:
            </p>
            <ol>
              <li>The first step is to configure the master node to boot to a command line interface (CLI) like you are using now, instead of a graphical user interface (GUI) like most modern operating systems have. Choose the following options in turn, navigating with the keyboard arrow keys and selecting each option with The Enter key:
                <ul>
                  <li><code>3 Boot Options</code></li>
                  <li><code>B1 Desktop/CLI</code></li>
                  <li><code>B1</code> again for <code>Console</code>.</li>
                </ul>

                <li>Next, change the Pi's hostname so you can easily identify it from the others in future. Follow the following options in the same ways as the previous step:</li>
                <ul>
                  <li><code>2 Network Options</code></li>
                  <li><code>N2 Hostname</code></li>
                </ul>

                <li>An information screen will appear, detailing what characters are allowed in the hostname - read it and select <code>&lt;Ok&gt;</code> to continue.</li>

                <li>On this screen, you will see the Raspberry Pi's current hostname. To make it more identifiable and customise your cluster, enter a new name of your choice. In my example I will change it to <i>beira</i> and hit enter/return to confirm it.</li>

                <li>Finally need to set the time zone so that the date and time on the Pi are correct. Once you are back at the main menu, select:</li>
                <ul>
                  <li><code>4 Localisation Options</code></li>
                  <li><code>I2 Change Timezone</code></li>
                </ul>

                <li>You will be presented with a list of geographic regions. Select where you are and hit Enter, then pick a city from the next list which is in your timezone. For example, if you were here in EPCC, you would pick 'Europe', and then 'London', since Edinburgh is not an option.</li>

                <li>Once back in the main menu, use the right arrow keys to select <code>&lt;Finish&gt;</code> and hit Enter/return.</li>

                <li>You will be asked if you want to reboot - choose yes. Your ssh session will end, and you will have to wait for a couple of minutes while the Raspberry Pi restarts</li>
              </ol>

        <p>
          If you log back in to your master node at this stage, you will see your new hostname now appears on the command line:
        </p>

        <pre>
  pi@beira:~ $
        </pre>

        <h3>Software Update and Passwordless Login</h3>
        <p>
          We will now install some updates on the Raspberry Pi main software:
        </p>

        <ol>
          <li>The first command to run is <code>rpi-update</code>:</li>
          <pre>
  pi@beira:~ $ sudo rpi-update
          </pre>
          <p>
            This will update the Raspberry Pi with the latest version of the core software and firmware for the system - it will take a few minutes and start with output like:
          </p>
          <pre>
   *** Raspberry Pi firmware updater by Hexxeh, enhanced by AndrewS and Dom
   *** Performing self-update
   *** Relaunching after update
   *** Raspberry Pi firmware updater by Hexxeh, enhanced by AndrewS and Dom
  #############################################################
  WARNING: This update bumps to rpi-4.9.y linux tree
  Be aware there could be compatibility issues with some drivers
  Discussion here:
  https://www.raspberrypi.org/forums/viewtopic.php?f=29&t=167934
  ##############################################################
  Would you like to proceed? (y/N)
          </pre>
          <p>
            Type <code>y</code>, then hit Enter. You will need to reboot the Raspberry Pi for this to take effect:
          </p>
          <pre>
  pi@beira:~ $ sudo reboot
          </pre>

          <li>Wait a few minutes while your master node reboots, then log back in via ssh.</li>
          <li>Before updating or installing any more software, begin setting up the passwordless login system that the cluster will need to run programs in parallel.
          <p>
            At the command line run the following:
          </p>
          <pre>
  pi@beira:~ $ ssh-keygen -t rsa
          </pre>
          <p>
            This will generate what is called a public/private key pair - this is a system used for encryption and security to allow information to be shared in private. This will generated public key is stored in a file, which can be given to any other machine or person you want to communicate with and a private file which has to be kept secret so that other people know that only you sent information to them or the information they send to you using your public key can only be read by you.
          </p>
          <li>Use the default file path for the first prompt, and then don’t put in a passphrase for this cluster (just press return/enter when you are asked for a pass phrase). Your interaction should look a little like:</li>
          <pre>
  pi@beira:~ $ ssh-keygen -t rsa
  Generating public/private rsa key pair.
  Enter file in which to save the key (/home/pi/.ssh/id_rsa):
  Created directory '/home/pi/.ssh'.
  Enter passphrase (empty for no passphrase):
  Enter same passphrase again:
  Your identification has been saved in /home/pi/.ssh/id_rsa.
  Your public key has been saved in /home/pi/.ssh/id_rsa.pub.
  The key fingerprint is:
  9b:98:c7:86:17:0a:1e:32:95:65:ee:1c:0f:48:48:ef pi@beira
  The key's randomart image is:
  +---[RSA 2048]----+
  | .... o          |
  |  .o *           |
  |    = +          |
  |   o o +         |
  |  o E o S        |
  |   + o * +       |
  |    . = B        |
  |       +         |
  |                 |
  +-----------------+
  pi@beira:~ $
          </pre>
          <li>Finally, we will update some of the operating system and installed software, run the command:</li>
          <pre>
  sudo apt-get update
          </pre>
          <p>
            When the prompt asks enter ‘<code>Y</code>’ and it will install the upgrades.
          </p>

          <li>Then upgrade the installed software to its latest versions - which include bug fixes and improvements - with this command:</li>
        </p>
        <pre>
          sudo apt-get upgrade
        </pre>
        <p>
          Depending on the number of upgrades, this can take a long time to complete. Once it's done, you are ready to move onto the next stage of setting up the master node.
        </p>
      </ol>

      <h3>Setting up the Shared File System</h3>
      <p>
        The next step is to set up the Network File System (NFS) server component.
      </p>
      <ol>
        <li>First thing we want to do is to add a network module, so run the following command:</li>

        <pre>
          sudo nano /etc/modules
        </pre>

        <p>
          This will open up a file like this one in the nano text editor:
        </p>
        <figure>
          <img src="images/nanomodules.png" alt="Text Editor"/>
          <figcaption>Adding ipv6</figcaption>
        </figure>

        <li>At the end of the file, using the cursor keys to move,  if it is not present (as it is above), add the following:</li>
        <pre>
  ipv6
        </pre>

        <li>To save the file and exit nano, enter the following keyboard shortcuts:</li>
        <ul>
          <li>CRTL + O to save.</li>
          <li>CTRL + X to close.</li>
        </ul>


        <li>Run the command:</li>
        <pre>
  sudo service rpcbind start
        </pre>

        <li>Next, install the NFS Kernel server. This is needed to run the server for the NFS drive.</li>
        <pre>
  sudo apt-get install nfs-kernel-server
        </pre>

        <li>Now create the actual shared location. Start by creating a directory in /home for sharing:</li>
        <pre>
          sudo mkdir -p /home/shared_dir
        </pre>
        <p>
          <code>mkdir</code> is a command used to create a directory (which can contain other directories and files).
        </p>
        <li>Change the new directory access permissions so that everyone can read or write to this directory:</li>
        <pre>
  sudo chmod 777 /home/shared_dir
        </pre>
        <p>
          <code>chmod</code> is a command to change the access permissions on a file or directory. Here 777 means that all users can read, write or execute commands in that directory. If you only want the owner to be able to write and others to only read you would use 644. This link will take you to the <a href="https://en.wikipedia.org/wiki/Chmod">chmod Wikipedia entry</a>.
        </p>

        <li>Now we need to mount the shared_dir and bind it in order to make it available to all nodes.</li>
        <pre>
  sudo mount --bind /home/shared_dir/ /home/shared_dir/
        </pre>

        <li>Now we need to make sure the directory gets mounted and exported each time the system boots up. Run the following command:</li>

        <pre>
  sudo nano /etc/fstab
        </pre>
        <p>
          At the end of the now open file add the following line, and save and close the file as before.
        </p>
        <pre>
          /home/shared_dir  /home/shared_dir   none   bind  0 0
        </pre>

        <li>Next, open the following file:</li>

        <pre>
  sudo nano /etc/default/nfs-kernel-server
        </pre>
        <p>
          Make sure that any one of the following options is present in the opened file:
        </p>
        <ul>
          <li>
            <pre>
  NEED_SVCGSSD=no
            </pre>
          </li>

          <li>
            <pre>
  NEED_SVCGSSD=“no”
            </pre>
          </li>

          <li>
            <pre>
  NEED_SVCGSSD=“”
            </pre>
          </li>

          <li>
            <pre>
  NEED_SVCGSSD=
            </pre>
          </li>
        </ul>

        <p>
          Save and close the file.
        </p>

        <li>The configuration process continues with a mapping file:</li>
        <pre>
  sudo nano /etc/idmapd.conf
        </pre>

        <p>
          Ensure that under the [Mapping] section the following text is present:
        </p>
        <pre>
  [Mapping]

  Nobody-User = nobody
  Nobody-Group = nogroup
        </pre>

        <li>Now run the following to expose the new directory to the network:</li>
        <pre>
  sudo nano /etc/exports
        </pre>
        <p>
          At the end of the file add the following to expose your shared_dir to the network, and allow read and write access (replacing with the first part of your IP addresses):
        </p>
        <pre>
  /home/shared_dir 192.168.2.0/24(rw,nohide,insecure,no_subtree_check,async)
        </pre>

        <li>Use the following command to reload the file now it's been modified:</li>
        <pre>
  exportfs -a
        </pre>

        <li>As a final check, examine the following files in nano:</li>

        <pre>
  /etc/init.d/nfs-kernel-server
  /etc/init.d/nfs-common
  /etc/init.d/rpcbind
        </pre>
        <p>
          Near the top of the file, there should be a line like this one:
        </p>

        <pre>
  # Default-Start:     2 3 4 5
        </pre>

        <p>
          <b>However</b> in some, it may say:
        </p>
        <pre>
  # Default-Start:     S
        </pre>

        <p>
          You need to change all the files that have an <code>S</code> to <code>2 3 4 5</code>.
        </p>

        <li>Run the following six commands:</li>
        <pre>
  sudo update-rc.d -f rpcbind remove
  sudo update-rc.d rpcbind defaults
  sudo update-rc.d -f nfs-common remove
  sudo update-rc.d nfs-common defaults
  sudo update-rc.d -f nfs-kernel-server remove
  sudo update-rc.d nfs-kernel-server defaults
        </pre>

        <p>
          (If any of these commands fail with error messages, try the following, then retry):
        </p>
        <pre>
  sudo apt-get purge rpcbind
  sudo apt-get install nfs-kernel-server

      </ol>

      <h3>Setting Up MPI</h3>
      <p>
        <a href="https://en.wikipedia.org/wiki/Message_Passing_Interface">MPI (Message Passing Interface)</a> is a core technology used in parallel and high performance computing that allows processes to communicate in a standard way, and so solve a problems together in parallel. We will install and test it with a simple program on a single node.
      </p>
      <ol>
        <li>Run the following to install necessary libraries:</li>
        <pre>
  sudo apt-get install libxml2-dev
  sudo apt-get install zlib1g zlib1g-dev
  sudo apt-get install mpich
        </pre>
        <li>Now try running the command:</li>
        <pre>
  mpiexec —version
        </pre>

        <p>
          The output should look something like this:
        </p>
        <pre>
  pi@beira:~ $ mpiexec --version
  HYDRA build details:
      Version:                                 3.2
      Release Date:                            Wed Nov 11 22:06:48 CST 2015
      CC:                              gcc   -Wl,-z,relro
      CXX:                             g++   -Wl,-z,relro
      F77:                             gfortran  -Wl,-z,relro
      F90:                             gfortran  -Wl,-z,relro
      Configure options:                       ...
      Process Manager:                         pmi
      Launchers available:                     ssh rsh fork slurm ll lsf sge manual persist
      Topology libraries available:            hwloc
      Resource management kernels available:   user slurm ll lsf sge pbs cobalt
      Checkpointing libraries available:       blcr
      Demux engines available:                 poll select

        </pre>

        <p><b>Note:</b> The output above has been shortened. Yours should have more detail.</p>
        <li>Now we will write a small program in C to test that MPI works on just one Raspberry Pi.</li>
        <p>
          Navigate to the shared_dir directory, create a new directory called <code>testprogram</code>, then go into that directory and create an empty file called <code>hello.c</code> with the following set of commands:
        </p>
        <pre>
  cd /home/shared_dir
  mkdir testprogram
  cd testprogram
  nano hello.c
        </pre>
        <li>Executing nano hello.c will open the empty file as well as create it. Type the following code, save, and exit:</li>
        <pre>
#include &lt;mpi.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char** argv) {
    // Initialize the MPI environment
    MPI_Init(NULL, NULL);

    // Get the number of processes
    int world_size;
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

    // Get the rank of the process
    int world_rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

    // Get the name of the processor
    char processor_name[MPI_MAX_PROCESSOR_NAME];
    int name_len;
    MPI_Get_processor_name(processor_name, &name_len);

    // Print off a hello world message
    printf("Hello world from processor %s, rank %d"
           " out of %d processors\n",
           processor_name, world_rank, world_size);

    // Finalize the MPI environment.
    MPI_Finalize();
}
        </pre>

        <li>To compile the code into an executable, do the following command:</li>
        <pre>
  mpicc -o hello hello.c
        </pre>

        <li>Type the command:</li>
        <pre>
  ls -al
        </pre>
        <p>
          This should show the directory contents - which will include an executable file called <code>hello</code>.
        </p>

        <li>Now we will run this as an MPI program. First we need to create a hostfile:</li>

        <pre>
  nano hostfile
        </pre>
        <p>
          and populate it with the address of your Raspberry Pi master node, followed by a <code>:4</code>. For example I need to type in:
        </p>
        <pre>
  192.168.2.18:4
        </pre>
        <p>
          Now save the file and exit nano.
        </p>

        <li>To run the <code>hello</code> program, type in the command:</li>
        <pre>
  mpiexec -n 4 -f hostfile ./hello
        </pre>
        <p>
          <code>mpiexec</code> command will run the program <code>hello</code> as an MPI program across 4 cores on the systems identified in your hostfile. This means that the program will run as four processes which can communicate with each other - in this case each process will only write out which core on the Raspberry Pi it is working on.
        </p>
        <p>
          You should get output like this:
        </p>
        <pre>
  pi@beira:/home/shared_dir/testprogram $ mpiexec -n 4 -f hostfile ./hello
  Hello world from processor beira, rank 0 out of 4 processors
  Hello world from processor beira, rank 1 out of 4 processors
  Hello world from processor beira, rank 2 out of 4 processors
  Hello world from processor beira, rank 3 out of 4 processors
      </pre>
        <p>
          If you do see this output like this then congratulations - you have setup MPI on your system and run a basic MPI program on it.
        </p>

        <h3>Setting Up the DHCP Server</h3>
        <ol>
          <li>The first step i s to enable Wifi on your master node. To do this, you need to add a network to the wpa_supplicant.conf file.</li>
          <p>
            Open wpa_supplicant.conf in nano:
          </p>
          <pre>
  sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
          </pre>
          <p>
            and the end of the file add:
          </p>
          <pre>
  network={
      ssid=“&lt;your ssid&gt;“
      psk=“&lt;your wifi code&gt;“
  }
          </pre>
          <p>
            <b>Note: The SSID is the WiFi network identifier - this is an identifier broadcast to allow you to select the right WiFi network. If you are running a home network - this will likely be on your router. Otherwise you can check to see what WiFi network your main computer is connected to from the WiFi network properties.</b><br/> As an example:
          </p>
          <pre>
  network={
    ssid="SKY64DBE"
    psk="UDAXEESQ"
  }
          </pre>
          <p>
            If you have a system like <i>eduroam</i> please have a look <a href="eduroam.html">here</a>.
          </p>
          <li>You may need to restart the wifi connection on your Raspberry Pi. Run the command:</li>
          <pre>
  sudo ifconfig wlan0 down
          </pre>
          <p>
            Wait for a few seconds then run:
          </p>
          <pre>
  sudo ifconfig wlan0 up
          </pre>
          <p>
            When you run the command:
          </p>
          <pre>
  ifconfig wlan0
          </pre>
          <p>
            You should get the output for the wifi with an IP address. Sharing this connection will be done after the next part.
          </p>

          <li>Now what we need to do is setup a DHCP server on this node - this will serve IP addresses to any other machine that wants to connect to its network and requests one.</li>
          <p>
            First we will install <code>dnsmasq</code>:
          </p>
          <pre>
  sudo apt-get install dnsmasq
          </pre>
          <li>Once installation is complete, we will need to configure the DHCP server. Open the configuration file for dnsmasq:</li>
          <pre>
  sudo nano /etc/dnsmasq.conf
          </pre>

          <p>
            Press CRTL + W which will start a search, type in <i>domain-needed</i> and press enter/return.
          </p>
          <p>
            Remove the # from the beginning of that line  (a # is a comment and tells the program to ignore the rest of the line, good for documenting your own changes).
          </p>
          <li>Also remove the # from the line that has <code>bogus-priv</code>.</li>
          <!-- The following instructions were changed from an earlier version which asked the reader to uncomment certain lines and amend some details. This is because they were quite difficult to follow and get right-->
          <li>Add the following lines to the end of the file:</li>
          <pre>
  server=/cluster/&lt;ip address of your main node&gt;
  local=/cluster/
  domain=cluster
  dhcp-range=&lt;first part of your node IP addresses&gt;.30,&lt;first part of your node IP addresses&gt;.100,14d
          </pre>
          <p>
            The last line will set the range of IP addresses that can be assigned to client machines (so for me this would be 192.168.2.30-192.168.2.100) and for how long they are assigned those addresses before they are renewed, known as lease time, in this case 14 days.
          </p>
          <p>
            Save this file now and exit the editor.
          </p>

          <li>Open the file called resolv.conf:</li>
          <pre>
  sudo nano /etc/resolv.conf
          </pre>
          <p>
            At the end of the file add <code>nameserver &lt;ip address of your main node&gt;</code>, for example:
          </p>
          <pre>
  nameserver 192.168.2.18
          </pre>
          <p>
            Save and exit.
          </p>
          <li>Then open the hosts file:</li>
          <pre>
  sudo nano /etc/hosts
          </pre>
          <p>
            At the end of the file add <i>&lt;ip address of your main node&gt; &lt;hostname of your main node&gt;</i>, for example:
          </p>
          <pre>
  192.168.2.18   beira
          </pre>
          <p>
            Then save and exit.
          </p>

          <li>Now we will fix the IP address of this Raspberry Pi - so that it is a fixed point we will always know.</li>
          <p>There are two tested versions of Raspbian for these instructions - "Wheezy" and "Jessie". New installations of Raspbian should be "Jessie" - commonly Raspberry Pi 3 computers, older Raspberry Pi 1 and 2 will if not upgraded likely be running "Wheezy". Use the instructions for your particular installation.</p>
        </ol>

        <h3>Network Configuration: Raspberry Pi "Wheezy"</h3>
        <p>There are two tested versions of Raspbian for these instructions - "Wheezy" and "Jessie". New installations of Raspbian should be "Jessie" - commonly Raspberry Pi 3 computers, older Raspberry Pi 1 and 2 will, if not upgraded, likely be running "Wheezy". Use the instructions for your particular installation.</p>
        <p>
          For Raspberry Pi running the Raspbian version denoted "Wheezy" (commonly non-upgraded Raspberry Pi 1 and 2) do the following:
        </p>
        <pre>
  sudo nano /etc/network/interfaces
        </pre>
        <p>
          In that file there will be a line:
        </p>
        <pre>
  iface eth0 net manual
        </pre>
        <p>
          We will change this to use  a static IP address. Replace the line with:
        </p>
        <pre>
  iface eth0 inet static
  address 192.168.2.18
  netmask 255.255.255.0
  network 192.168.3.0
  broadcast 192.168.2.255
  gateway 192.168.2.1
        </pre>
        <p>
          <b>Note:</b> Use the IP Address of your node in place of my example 192.168.2.18.
        </p>
        <p>
        Save this file and exit now.
       </p>
        <p>
        Now start the service and reboot:
        </p>
        <pre>
sudo service dnsmasq start
sudo reboot
</pre>
<p>
Then log back into the Raspberry Pi.
  </p>
<h3>Network Configuration: Raspberry Pi "Jessie"</h3>
For Raspberry Pi computers running Raspbian version denoted "Jessie" (commonly Raspberry Pi 3), run:
    <pre>
    sudo nano /etc/dhcpcd.conf
</pre>
        <p>
At the bottom of the file add:
          </p>
<pre>
interface eth0

static ip_address=192.168.2.18/24
</pre>
<p>
Now start the service and reboot:
          </p>
<pre>
sudo service dnsmasq start
sudo reboot
</pre>
   <p>
Then log back into the Raspberry Pi.
  </p>

   <h3>On All Systems</h3>
        <p>
If you disable the internet sharing on your laptop/desktop you will find that you get an IP address from the Pi on the ethernet.
  </p>
        <p>
If you have configured wifi to connect to your internet, you can share this across the network being served by the Raspberry Pi via its ethernet connection.
  </p>
        <p>
On the host Raspberry Pi run:
          </p>
<pre>
 sudo nano /proc/sys/net/ipv4/ip_forward
</pre>
        <p>
Change the value 0 to 1, then save and exit.
</p>
        <p>
Then run:
        </p>
<pre>
sudo iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
</pre>
        <p>
This will share the connection across any machines getting IP addresses from this Pi.
</p>
        <p>
However if you reboot the Pi, this sharing will be lost.
</p>
        <p>
What we need to do is make the iptables persistent and the forwarding permanent.
</p>
        <p>
To do this run:
        </p>
<pre>
sudo nano /etc/sysctl.conf
</pre>
        <p>
For the line #net.ipv4.ip_forward=1 remove the #.
</p>
        <p>
Now run the following commands to make the iptables changes load each time:
        </p>
<pre>
sudo iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
sudo apt-get install iptables-persistent
</pre>
        <p>
When it asks you if you want to save the current configuration, say yes both times.
</p>
        <p>
This will add the wifi sharing as a permanent feature of your cluster.
</p>
        <p>
Now you have made changes to your main node which will do the following:
        </p>
<ul>
<li>Share a network drive.</li>
<li>Run a DHCP Server.</li>
<li>Run an MPI program.</li>
<li>Share Internet Connections.</li>
</ul>


<a name="workers"><h3>Setting up the worker nodes</h3></a>
        <p>
Now what we need to do is configure the worker nodes.
</p>
<p>
First we need to know what addresses they have - if you are continuing to use internet sharing from a laptop/desktop use the instructions from  <a href="#sharing">earlier.</a>
</p>
<p>
If you are sharing from your new master node, then you can find out the ip addresses like this:
</p>

    <pre>
less /var/lib/misc/dnsmasq.leases
</pre>
        <p>
This will list the connected machines to the master node.
</p>
<p>
One of these will be your laptop/desktop.
        </p>

<pre>
1471486087 b8:27:eb:1d:52:f6 192.168.2.55 raspberrypi 01:b8:27:eb:1d:52:f6
1471486084 b8:27:eb:47:a1:27 192.168.2.39 * 01:b8:27:eb:47:a1:27
1471486081 b8:27:eb:cf:a3:29 192.168.2.62 * 01:b8:27:eb:cf:a3:29
1471486081 b8:27:eb:0c:4d:4e 192.168.2.72 * 01:b8:27:eb:0c:4d:4e
1471482976 34:15:9e:07:d4:42 192.168.2.47 Khonsu 01:34:15:9e:07:d4:42
</pre>
        <p>
You will notice some of the lines have a "*" - this is because all the worker nodes have the same hostname which doesn’t really work on a network. Your laptop or desktop should have a name, in my example it is Khonsu.
</p>
<p>
We are going to do a manual configuration change to fix this, but we could write a script to run on all our nodes so that we don’t have to type a lot ourselves. If this is not the first time you have created a cluster, you can create a script, if it is the first time it may be more reassuring to do it yourself.
</p>
<p>
So on each node you need to login:
        </p>

<pre>
ssh pi@&lt;address&gt;
</pre>
        <p>
You will get the ssh certificate warning which you can ignore, then you will need to type your password in.
</p>
<p>
    Once logged in - you will need to run the raspi-config again and choose the same settings options as you did for the master node - just with a different hostname and remember to set the timezone - <a href="#configrpi" >see the main system configuration</a>. Here is the list of raspi-config steps:

    <ul>
<li>Choose option 3 Boot Options.</li>
<li>Now choose option B1 Text console and hit enter/return.</li>
<li>Now choose the option 9 Advanced Options.</li>
<li>Choose the Option A2 Hostname and hit enter/return.</li>
  <li>Set Hostname</li>
    <li>Choose Option 5 Internationalisation Options.</li>
<li>Choose the T2 Change Timezone option.</li>
  <li>  From the list choose your area, for me it is Europe</li>
    <li>Then choose your closest location, I chose London.</li>
        </ul>
        </p>
        <p>
For my example, I will just call them worker01-worker04 so if I look at the leases in dnsmasq:
        </p>
    <pre>
1471486724 b8:27:eb:1d:52:f6 192.168.2.55 worker01 01:b8:27:eb:1d:52:f6
1471486758 b8:27:eb:47:a1:27 192.168.2.39 worker02 01:b8:27:eb:47:a1:27
1471486815 b8:27:eb:cf:a3:29 192.168.2.62 worker03 01:b8:27:eb:cf:a3:29
1471486841 b8:27:eb:0c:4d:4e 192.168.2.72 worker04 01:b8:27:eb:0c:4d:4e
1471482976 34:15:9e:07:d4:42 192.168.2.47 Khonsu 01:34:15:9e:07:d4:42
</pre>
        <p>
I can login to the nodes with their IP Address now if the configuration of the server has worked correctly.
</p>
        <p>
You will need to generate an ssh key with ssh-keygen for each machine.
</p>
        <p>
Now you will have four workers each with their own ssh keys.
</p>
        <p>
Now you will have to update them all.
</p>
        <p>
You can open up multiple terminals and on each worker run the following command:
        </p>
    <pre>
sudo rpi-update
</pre>
        <p>
This means all the workers are updating at the same time.
</p>
        <p>
Once the update has completed - you will need to reboot.
</p>
        <p>
To save a lot of typing - what we will do is set up passwordless login within the cluster - we need this for parallel programs to work and it saves us time as well.
</p>
        <p>
First we will set up passwordless login from the master node to the worker node.
            </p>
        <p>
Log into the master node and then for each of your workers run the following:
        </p>
    <pre>
ssh-copy-id pi@&lt;worker node&gt;
</pre>
        <p>
Each time you will need to enter a password.
</p>
        <p>
Now you will need to do this on each of the workers - doing an ssh-copy-id to all the other nodes.
</p>
        <p>
Now that will take a little time to type in but it will save time in the future.
</p>

        <p>
On each worker run:
        </p>
<pre>
sudo nano /etc/hosts
</pre>
        <p>
At the end of the file add:
        </p>
<pre>
&lt;ip address of your server node&gt; &lt;name of your server&gt;
</pre>
    <p>
for my example:
    </p>
<pre>
192.168.2.18 beira
</pre>
            <p>
Now we need to update the OS on each worker.
</p>
        <p>
Run the command:
        </p>
    <pre>
sudo apt-get update && sudo apt-get upgrade
</pre>
        <p>
You will need to confirm on each worker that you want the install to continue.
</p>
        <p>
This will take some time to install even if they are all going at the same time.
</p>
        <p>
After they are updated we need to install some additional packages:
        </p>
<pre>
sudo apt-get install libxml2-dev
sudo apt-get install zlib1g zlib1g-dev
sudo apt-get install mpich
</pre>
          <p>
Now you should be able to run:
        </p>

    <pre>
mpiexec —version
</pre>
<p>
However, we are not quite finished with the software setup. We need to setup the mounted shared drive.
</p>
        <p>
Start on each node by doing this:
        </p>
    <pre>
sudo mkdir /home/shared_dir
sudo chmod 777 /home/shared_dir/
</pre><p>
ON each node run:
        </p>
    <pre>
sudo apt-get purge rpcbind
sudo apt-get install nfs-common
</pre><p>
You will need to do this on each node:
        </p>
    <pre>
/etc/init.d/nfs-common
/etc/init.d/rpcbind
</pre>
        <p>
Have a look at the above files in nano.
</p>
        <p>
Each file should have a line near the top with:
        </p>
    <pre>
# Default-Start:     2 3 4 5
</pre>
        <p>
However, as before, in some it may have:
        </p>
    <pre>
# Default-Start:     S
</pre>
        <p>
Change all the S to 2 3 4 5.
</p>
        <p>
Then run:
    <pre>
sudo update-rc.d -f rpcbind remove
sudo update-rc.d rpcbind defaults

sudo update-rc.d -f nfs-common remove
sudo update-rc.d nfs-common defaults
</pre>
        <p>
We are going to address the shared nfs drive by its IP address:
        </p>

<pre>
sudo mount 192.168.2.18:/home/shared_dir /home/shared_dir
</pre>
        <p>
This will only mount the drive a single time - when you reboot the Pi the changes will be lost.
</p>
        <p>
So we need to add it to some configuration that will do this automatically, run:
    </p>
    <pre>
sudo nano /etc/fstab
</pre><p>
at the end of the file add:
        </p>
    <pre>
192.168.2.18:/home/shared_dir /home/shared_dir nfs rw,hard,intr,noauto,x-systemd.automount 0 0
</pre>
        <p>
Now you can reboot everything so on each node run:
        </p>
    <pre>
sudo reboot
</pre>
        <p>
Now we will test our simple hello world across multiple nodes -
login to the master node:
        </p>
<pre>
cd /home/shared_dir/testprogram
nano hostfile
</pre>
        <p>
in the hostile add the IP addresses of your nodes (not the ones in the example unless they match up) with a :4 at the end like this:
        </p>
<pre>
192.168.2.18:4
192.168.2.72:4
192.168.2.55:4
192.168.2.39:4
192.168.2.62:4
</pre>
        <p>
Save and exit nano.
</p>
        <p>
Run the following command:
        </p>
<pre>
mpiexec -n 20 -f hostfile ./hello
</pre>
        <p>
and it should give output like:
        </p>
<pre>
Hello world from processor worker03, rank 16 out of 20 processors
Hello world from processor worker03, rank 17 out of 20 processors
Hello world from processor worker03, rank 18 out of 20 processors
Hello world from processor worker03, rank 19 out of 20 processors
Hello world from processor worker04, rank 4 out of 20 processors
Hello world from processor worker04, rank 5 out of 20 processors
Hello world from processor worker01, rank 8 out of 20 processors
Hello world from processor worker04, rank 6 out of 20 processors
Hello world from processor worker01, rank 9 out of 20 processors
Hello world from processor worker04, rank 7 out of 20 processors
Hello world from processor worker01, rank 10 out of 20 processors
Hello world from processor worker01, rank 11 out of 20 processors
Hello world from processor worker02, rank 12 out of 20 processors
Hello world from processor worker02, rank 13 out of 20 processors
Hello world from processor worker02, rank 14 out of 20 processors
Hello world from processor worker02, rank 15 out of 20 processors
Hello world from processor beira, rank 1 out of 20 processors
Hello world from processor beira, rank 3 out of 20 processors
Hello world from processor beira, rank 0 out of 20 processors
Hello world from processor beira, rank 2 out of 20 processors
</pre>
        <p>
Congratulations, if you got this then you have put together a basic cluster for running parallel programs on.
</p>

        <p>
To turn off  a Raspberry Pi, type:
        </p>
    <pre>sudo halt</pre>

     <p>
To see how fast your cluster is, the next instruction set will show you how to install a benchmark and how to run it.
</p>

<a name="bench"><h3>Running a benchmark</h3></a>
<p>
Linpack is a commonly used benchmark to test how “fast” a supercomputer can go. What we are going to do is install linpack on your cluster and test how fast your cluster is.
</p>

        <p>
The first thing to do is to log into your cluster and connect it to the internet.
</p>

        <p>
We are going to run the HPL - High Performance Linpack Benchmark on your cluster, more information on this can be found at <a href="http://www.netlib.org/benchmark/hpl/">Linpack</a>.
        </p>
<h4>Software Setup:</h4>
<p>
On each node, we need some additional software so run the following command on each of the nodes:
 </p>
    <pre>
 sudo apt-get install libatlas-base-dev gfortran
</pre>
        <p>
Now use the following command to change to the shared drive:
         </p>
<pre>
cd /home/shared_dir
</pre>
        <p>
Now, create a linpack directory:
         </p>
<pre>
mkdir linpack
cd linpack
</pre>
        <p>
Now download the HPL source:
         </p>
    <pre>
wget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz
</pre>
        <p>
This file is a compressed archive to make it quicker to download, we will now extract the archive:
        </p>
<pre>
tar xf hpl-2.2.tar.gz
</pre>
        <p>
Change into the new directory and into the setup directory:
         </p>
<pre>
cd hpl-2.2/setup
</pre>
        <p>
Run the following command:
         </p>
<pre>
sh make_generic
</pre>
        <p>
Change to the parent directory:

     </p>
    <pre>
cd ..
</pre>
        <p>
Copy the Make.UNKNOWN file and call it Make.rpi.
         </p>
<pre>
cp setup/Make.UNKNOWN Make.rpi
</pre>
        <p>
Now we will edit the file:
         </p>
<pre>
nano Make.rpi
</pre>
        <p>
Press CRTL+W and search for ARCH.
 </p>
        <p>
The line should say ARCH = UNKNOWN.
         </p>
<pre>
Change unknown to rpi
</pre>
        <p>
Search for TOPdir.
 </p>
Change the value for TOPdir to:
    <pre>
/home/shared_dir/linpack/hpl-2.2
</pre>
        <p>
We could set the first part of this to an environment variable but that is another topic.
 </p>
        <p>
A few lines below you will find three blank entries Mkdir, MPinc, MPlib.
 </p>
        <p>
Set these to the values shown below:
 </p>
    <pre>
MPdir        = /usr/lib
MPinc        = -I $(MPdir)/mpich/include
MPlib        = $(MPdir)/arm-linux-gnueabihf/libmpich.a

LAdir        = /usr/lib/atlas-base/
LAinc        = $(LAdir)/libf77blas.a $(LAdir)/libatlas.a
LALib        = -lblas

</pre>
        <p>
Save the file and exit nano, then type the command:
         </p>
<pre>
make arch=rpi
</pre>
        <p>
This will compile the benchmark.
 </p>
        <p>
Now we need to create a data file to test with:
     </p>
<pre>
cd bin/rpi
nano HPL.dat
</pre>
        <p>
Now enter the following text into the HPL.dat file:
         </p>
<pre>
HPLinpack benchmark input file
Innovative Computing Laboratory, University of Tennessee
HPL.out      output file name (if any)
6            device out (6=stdout,7=stderr,file)
1            # of problems sizes (N)
5040         Ns
1            # of NBs
128          NBs
0            PMAP process mapping (0=Row-,1=Column-major)
1            # of process grids (P x Q)
1            Ps
1            Qs
16.0         threshold
1            # of panel fact
2            PFACTs (0=left, 1=Crout, 2=Right)
1            # of recursive stopping criterium
4            NBMINs (>= 1)
1            # of panels in recursion
2            NDIVs
1            # of recursive panel fact.
1            RFACTs (0=left, 1=Crout, 2=Right)
1            # of broadcast
1            BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)
1            # of lookahead depth
1            DEPTHs (>=0)
2            SWAP (0=bin-exch,1=long,2=mix)
64           swapping threshold
0            L1 in (0=transposed,1=no-transposed) form
0            U  in (0=transposed,1=no-transposed) form
1            Equilibration (0=no,1=yes)
8            memory alignment in double (> 0)

</pre>
        <p>
        Save the file and exit nano.
 </p>
        <p>
Then in the bin/rpi directory run:
         </p>
    <pre>
./xhpl
</pre>
        <p>
This will produce output like:
         </p>
    <pre>
================================================================================
HPLinpack 2.2  --  High-Performance Linpack benchmark  --   February 24, 2016
Written by A. Petitet and R. Clint Whaley,  Innovative Computing Laboratory, UTK
Modified by Piotr Luszczek, Innovative Computing Laboratory, UTK
Modified by Julien Langou, University of Colorado Denver
================================================================================

An explanation of the input/output parameters follows:
T/V    : Wall time / encoded variant.
N      : The order of the coefficient matrix A.
NB     : The partitioning blocking factor.
P      : The number of process rows.
Q      : The number of process columns.
Time   : Time in seconds to solve the linear system.
Gflops : Rate of execution for solving the linear system.

The following parameter values will be used:

N      :    5040
NB     :     128
PMAP   : Row-major process mapping
P      :       1
Q      :       1
PFACT  :   Right
NBMIN  :       4
NDIV   :       2
RFACT  :   Crout
BCAST  :  1ringM
DEPTH  :       1
SWAP   : Mix (threshold = 64)
L1     : transposed form
U      : transposed form
EQUIL  : yes
ALIGN  : 8 double precision words

--------------------------------------------------------------------------------

- The matrix A is randomly generated for each test.
- The following scaled residual check will be computed:
      ||Ax-b||_oo / ( eps * ( || x ||_oo * || A ||_oo + || b ||_oo ) * N )
- The relative machine precision (eps) is taken to be               1.110223e-16
- Computational tests pass if scaled residuals are less than                16.0
    </pre>
        <p>
and this will take some time to run.
 </p>
        <p>
Then in the end it will produce output like:
 </p>
<pre>
================================================================================
T/V                N    NB     P     Q               Time                 Gflops
--------------------------------------------------------------------------------
WR11C2R4        5040   128     1     1             317.11              2.693e-01
HPL_pdgesv() start time Thu Aug 18 09:28:47 2016

HPL_pdgesv() end time   Thu Aug 18 09:34:04 2016

--------------------------------------------------------------------------------
||Ax-b||_oo/(eps*(||A||_oo*||x||_oo+||b||_oo)*N)=        0.0021492 ...... PASSED
================================================================================

Finished      1 tests with the following results:
              1 tests completed and passed residual checks,
              0 tests completed and failed residual checks,
              0 tests skipped because of illegal input values.
--------------------------------------------------------------------------------

End of Tests.
================================================================================
</pre>
        <p>
The numbers will vary but this result about shows that a single Raspberry Pi 3 achieves 269.3Mflops (see under the Gflops column at the top).
 </p>
<p>
Now what we will do is run LINPACK across our cluster.
 </p>
        <p>
The first thing you need to do is to create a hostfile with the ip addresses of your nodes.
         </p>
    <pre>
192.168.2.18:4
192.168.2.72:4
192.168.2.55:4
192.168.2.39:4
192.168.2.62:4
</pre>
        <p>
Now you will need to edit your HPL.dat:
        </p>
<pre>
HPLinpack benchmark input file
Innovative Computing Laboratory, University of Tennessee
HPL.out      output file name (if any)
6            device out (6=stdout,7=stderr,file)
1            # of problems sizes (N)
17400         Ns
1            # of NBs
128          NBs
0            PMAP process mapping (0=Row-,1=Column-major)
1            # of process grids (P x Q)
4            Ps
5            Qs
16.0         threshold
1            # of panel fact
2            PFACTs (0=left, 1=Crout, 2=Right)
1            # of recursive stopping criterium
4            NBMINs (>= 1)
1            # of panels in recursion
2            NDIVs
1            # of recursive panel fact.
1            RFACTs (0=left, 1=Crout, 2=Right)
1            # of broadcast
1            BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)
1            # of lookahead depth
1            DEPTHs (>=0)
2            SWAP (0=bin-exch,1=long,2=mix)
64           swapping threshold
0            L1 in (0=transposed,1=no-transposed) form
0            U  in (0=transposed,1=no-transposed) form
1            Equilibration (0=no,1=yes)
8            memory alignment in double (> 0)

</pre>
        <p>
Then run the program using mpiexec:
         </p>
<pre>
mpiexec -n 20 -f hostfile ./xhpl
</pre>
        <p>
This will output information like the last run just for the whole cluster.
 </p>
<p>
For my example cluster a test run came out 2.403Gflops.
 </p>
        <p>
Your speeds will vary. This is the default setup for Linpack on this cluster - we have been exploring ways of getting better performance - for example we can change some of the software libraries in the benchmark for more efficient ones, this has proven to give far better performance numbers.
 </p>
        <p>Further instructions for tweaking your cluster and installing demos from EPCC and ARCHER will be appearing in the future. Monitor our blog at <a href="https://www.epcc.ed.ac.uk/blog">https://www.epcc.ed.ac.uk/blog</a> and Twitter feed at <a href="https://twitter.com/EPCCed">https://twitter.com/EPCCed</a> for related announcements. And track this page for updates at <a href="https://epcced.github.io/wee_archlet/">Wee Archlet HTML</a> and the <a href="https://github.com/EPCCed/wee_archlet/">Git repository</a>.</p>

<p>
<b>Note:</b> If the network connections appear to break connection (error message comes up) or freeze (network becomes unresponsive), add the following line to the file /etc/sysctl.conf:
     </p>
        <pre>vm.min_free_kbytes = 16384 </pre>


    </body>
</html>
