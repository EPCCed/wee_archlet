<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Building a Little Cluster</title>
        <meta name="description" content="a guide to setting up a raspberry pi cluster">
        <link rel="stylesheet" href="css/main.css">
    </head>
    <body>
        <img src="images/walogo.png"/>

        <h1>Raspberry Pi Cluster Setup</h1>

        <ul>
          <li><a href="#intro">Setting up a Raspberry Pi Cluster</a></li>
          <li><a href="#command">Command Terminals</a></li>
          <li><a href="#materials">Materials</a></li>
          <li><a href="#connections">Connecting the Pi-s</a></li>
          <li><a href="#mainnode">Setting Up the Main Node</a></li>
          <li><a href="#workers">Setting up the worker nodes</a></li>
          <li><a href="#bench">A Quick Benchmark</a></li>
          <li><a href="https://www.epcc.ed.ac.uk/discover-and-learn/resources-and-activities/what-is-a-supercomputer/wee-archie">Wee Archie</a></li>
          <!--TODO Add link to command glossary which I am going to make-->
          <li>Glossary of commands</li>
        </ul>

        <h2>Version and Authorship</h2>
        <table>
          <tr><td><b>Version</b></td><td>0.96</td></tr>
          <tr><td><b>Author</b></td><td>A Grant (EPCC)</td></tr>
          <tr><td><b>Contributors</b></td><td>M Antonioletti (EPCC), O T Brown (EPCC), J Kennedy (EPCC), G Gibb (EPCC),  R MacLeod (EPCC)</td></tr>
          <tr><td><b>Notes</b></td><td>Linux Network Connection to be completed. </td></tr>
          <tr><td><b>Notes</b></td><td>Raspbian SSH Access Note added. </td></tr>
        </table>

        <a name="intro"><h2>Before You Start</h2></a>

        <p>These instructions will help you set up a small cluster of Raspberry Pi computers as a small parallel system. They will take you through the process of connecting the Pis together, setting up the environment and checking that it works correctly.
        </p>
        <p>
          These instructions are not for complete beginners with computers - they assume knowledge of concepts such as networks, command line and file systems. There are some explanations in this document but still require some experience and a willingness to try things out.
        </p>
        <p>
          <b>Note:</b> these instructions deal with a cluster of 5 Raspberry Pis but the cluster can be of any size you want (minimum of 2, as otherwise it is not a parallel computer!)
        </p>
         <p>
           <b>Note:</b> Raspbian refers to the version of Linux commonly distributed with the Raspberry Pi computers. New Out Of Box Software (NOOBS) is an easy-to-use installation manager for Raspian which you can use if you're setting up your Pis for the first time.
         </p>
        <p>
          <b>Note:</b>If you try these instructions and find any issues or have suggestions, please submit an issue to <a href="https://github.com/EPCCed/wee_archlet/issues">our GitHub repo</a>.
        </p>
        <a name="command">Command Terminals</a>
        <p>
          This document will refer to command terminals throughout, when accessing, configuring, and controlling the Raspberry Pis from your computer. A command terminal provides a textual interface to a user, rather than a graphical interface that you might be more used to. Command line interfaces often look like:
          <figure>
            <img src="images/terminal.png" alt="Terminal"/>
            <figcaption>Example Terminal</figcaption>
          </figure>
          Sometimes they will have light text on a dark background - you can configure them to your own liking. Regardless, a Raspberry Pi uses the Linux operating system and will have a terminal that functions and behaves in the same way this document describes.
        </p>
        <p>
          On a Linux system, you will need to open a command terminal on your computer - you may be able to get this using a right mouse click and choosing "Terminal", or from a list of programs in the program menu.
        </p>
        <p>
          On Windows 10 you can use PowerShell, which you can find through the search feature in the taskbar. If you prefer, you can install a Secure Shell (SSH) client to connect to the Raspberry Pis. Two free options are: - <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</a>, and <a href="https://mobaxterm.mobatek.net/">MobaXterm</a>. These instructions assume that you are working from the command line, so if you are using an SSH client please check its documentation so you know how it works.
        </p>
        <p>
          On a Mac OS machine, Terminal is under Utilities in the Applications folder.
        </p>

       <a name="materials"><h2>Materials</h2></a>
       <h3>You will need:</h3>
       <ul>
         <li>5 Raspberry Pis (Note the examples used in these instructions are Raspberry Pi 3s - the instructions should work for most Raspberry Pi models - if problems are encountered please submit an issue to <a href="https://github.com/EPCCed/wee_archlet/issues">Cluster Instructions</a>).</li>
         <li>5 Power Supplies/1 Multisupply Unit.</li>
         <li>1 Switch (with at least 8 Ports).</li>
         <li>6 Ethernet Cables.</li>
         <li>5 Power cables. </li>
         <li>Laptop or desktop PC with a shareable ethernet connection.</li>
      </ul>

      <h3>Optionally:</h3>
        <ul>
          <li>5 <a href="#case">Raspberry Pi cases - we've used <a href="http://cpc.farnell.com/multicomp/cbpiblox-red/pi-blox-enclosure-red-rev3/dp/SC14019">Lego-Style cases</a>, which are stackable</a>.</li>
        </ul>

      <h3>Suitable and Unsuitable Raspberry Pi Models</h3>
      <p>
        <b>NOTE:</b>There are many products with the Raspberry Pi name so this is a list of the ones that are suitable and unsuitable for these instructions.
      </p>
      <p>
        Suitable Raspberry Pi Models (these instructions work for these types of Raspberry Pi):
      </p>
      <ul>
        <li>Raspberry Pi 3</li>
        <li>Raspberry Pi 2</li>
      </ul>
      <p>
        Unsuitable Raspberry Pi Models (these instruction will not work or require substantial changes and/or additional hardware):
      </p>
      <ul>
        <li>Raspberry Pi Zero</li>
        <li>Raspberry Pi Zero W</li>
        <li>Raspberry Pi Compute Module</li>
      </ul>

      <p>
        At the time of writing there are three types of  Raspberry Pi in the market - to distinguish between them we provide the following images:
      </p>
      <figure>
        <img src="images/11546-04.jpg" alt="Raspberry Pi 1"/>
        <figcaption>Raspberry Pi 1 Model B</figcaption>
      </figure>
     <figure>
        <img src="images/Raspberry-Pi-2-Bare-BR.jpg" alt="Raspberry Pi 2"/>
        <figcaption>Raspberry Pi 2 Model B</figcaption>
      </figure>
     <figure>
        <img src="images/Raspberry_Pi_3_Model_B.png" alt="Raspberry Pi 3"/>
        <figcaption>Raspberry Pi 3 Model B</figcaption>
     </figure>

     <p>
       If you are using cases - this is the point where you should put the Raspberry Pi into its case. An example of a cased Raspberry Pi would look like this:
     </p>
     <figure>
       <a name="case"/>
       <img src="images/IMG_20160906_105359475.jpg" alt="Cased Raspberry Pi Open"/>
       <figcaption>Lego Style Case - Open</figcaption>
     </figure>
     <figure>
       <img src="images/IMG_20160906_105327393.jpg" alt="Cased Raspberry Pi Closed"/>
       <figcaption>Lego Style Case - Closed</figcaption>
     </figure>

      <h3>Materials used in these instructions:</h3>
      <p>
        We've used Raspberry Pi 3s for our cluster. In place of 5 mains power supplies, we've chosen <a href="http://www.farnell.com/datasheets/1948264.pdf">1 Multi-USB Power Socket. Note - This particular model appears to have been discontinued.</a> Each pi is connected to this via a USB to B-type Micro USB cable. Our switch is a Netgear GS108E.
      </p>

      <h3>Important Note for New Raspbian Installations</h3>
      <p>
        Due to changes in the recent versions of Raspbian and the NOOBS distributions, to follow these instructions you have to make a change to your Raspberry Pi SD Card before you boot it up for the first time.
      </p>
      <p>
        Newer versions of Raspbian have SSH access disabled by default. To reenable it, you will need to insert the microSD cards containing Raspbian into your computer and create a blank text file called 'SSH' in the boot partition. This will be the disk that appears in your file system when you insert the microSD card.
      </p>
      <p>
        Once you have created the file, you will be able to boot Raspbian with SSH remote access enabled.
      </p>

      <h2><a name="connections">Connecting the Raspberry Pi Cluster</a></h2>
      <ol>
        <li>
          Connect the Ethernet Cables to the ethernet ports:
        </li>

        <figure>
          <img src="images/IMG_20170210_132818620.jpg" alt="Ether Pi"/>
          <figcaption>Connect Ethernet to Pi</figcaption>
        </figure>

        <li>
          Connect the ethernet cables to the switch:
        </li>

        <figure>
          <img src="images/IMG_20170210_132909899.jpg" alt="Ether Switch"/>
          <figcaption>Connect Ethernet to Switch</figcaption>
        </figure>

        Now it should look something like:
        <figure>
          <img src="images/IMG_20170210_132914225.jpg" alt="Ethernet"/>
          <figcaption>Connected</figcaption>
        </figure>

        <li>
          Connect your laptop or desktop to the switch via an ethernet cable. (Note that while Raspberry Pi 3 has a builtin wireless network - we are not using this and at this point it probably would not have been set up.)
        </li>

        <li>
          Now all the network cables are connected - we need to put the power cables in. First connect the power cable for the switch and turn it on:
        </li>

        <figure>
          <img src="images/IMG_20170210_132948565.jpg" alt="Ethernet"/>
          <figcaption>Switch Power</figcaption>
        </figure>

        <li>
          Now connect each of the Raspberry Pis to your power supply and turn them on. In this case we are using an externally powered USB-hub:
        </li>

        <figure>
         <img src="images/IMG_20170210_133056149.jpg" alt="Ethernet"/>
         <figcaption>Raspberry Pi Power</figcaption>
        </figure>

       <figure>
         <img src="images/IMG_20170210_133126552_HDR.jpg" alt="Ethernet"/>
         <figcaption>Plug in</figcaption>
       </figure>

       And that's it! All the Pi units should have LED lights on or flashing, and look something like this:

      <figure>
        <img src="images/IMG_20170210_133145864.jpg" alt="Ethernet"/>
        <figcaption>Our Cluster</figcaption>
      </figure>

    </ol>

    <h2><a name="sharing">Network Software Setup</a></h2>

        <p><b>Note: </b>These instructions assume you are using a computer connected to a WiFi network and that this computer has a free Ethernet port to connect to the cluster.</p>
  <p>
First on your laptop/desktop you will have to configure the internet sharing:
</p>
<h4>Mac OS</h4>
<ul>
<li>Go to System Perferences</li>

<li>Choose Sharing </li>
         <figure>
<img src="images/mac-preferences.png" alt="Mac preferences"/>
            <figcaption>Mac preferences</figcaption>
            </figure>
<li>Click on Internet Sharing and choose share from Wifi to Ethernet </li>
</ul>
    <p>
This will start a service which shares the connection from the WiFi across the Ethernet connection (through the switch) to the Raspberry Pis.
</p>
<h4>Windows 10</h4>
        <h5>Share Network Connection</h5>
        <ul>
            <li>Open Settings</li>
            <li>Choose Network and Internet</li>
            <li>Choose "Network and Sharing Center</li>
            <li>Choose "Change adapter options"</li>
            <li>Select the Wi-Fi connection (this maybe called something else on your computer but should be identifiable as being connected to a wireless network by a signal strength in the icon.)</li>
             <li>Right Click and Choose "Properties"</li>
             <li>Select the Sharing Tab</li>
             <li>Under Sharing, click the box at "Allow other network users to connect through this computer's Internet Connection.</li>
              <li>Ensure that the Home networking connection is your Ethernet network in the box below.</li>
             <li>Your internet is now shared but you will need to use Nmap to get the attached IP addresses for the Raspberry Pis.</li>
             <li>In the Network Connections where you selected the Wi-Fi connection, there should be a Ethernet connections, right click on it and choose Properties.</li>
             <li>In the list headed "This connection uses the following items", click on the one called "Internet Protocal Version 4"</li>
              <li>A Properties button will enable just below the list - click on it.</li>
              <li>Take a note of the IP Address and Subnet Mask listed.</li>
             <li>You can close these dialog boxes.</li>
        <li>Now click on this link:<a href="#winnmap">Windows IP Address Discovery</a> to get instructions on how to get the Raspberry Pi IP addresses.</li></ul>

<h4>Linux</h4>
<h5>Ubuntu</h5>
<ul>
  <li>Open a terminal</li>
  <li>Open the network connection editor by running the command: <pre>nm-connection-editor</pre></li>
  <li>Select your internet connection, then click the cog icon to edit the connection settings
  <figure>
    <img src="images/ubuntu_nm-connection-editor.png" alt="nm-connection-editor"/>
    <figcaption>Edit network connection</figcaption>
  </figure>
  <li>Select the "IPv4 Settings" tab</li>
  <li>Select "Shared to other computers" from the "Method" drop-down list</li>
  <li>Click "Save", and close the connection editor</li>
</ul>

<h3>Getting into the Pi</h3>
<h4>MacOS and Linux</h4>
        <p>
Finding out the IP addresses of your Raspberry Pis. For the setup used here, the shared network connection showed up as an adapter called Bridge100 after running ifconfig. This is what allows the WiFi connection to be shared to the Ethernet connection.
</p>
<p>
  <b>Note:</b> Bridge100 may be using some other name on your computer, especially if you are using Linux. To check which interface is created - type ifconfig before turning on your sharing or plugging in your adapter then run it again afterwards to find out what difference the changes made.
</p>
<p>
  <b>Note:</b> On more recent versions of Linux (Ubuntu 18.04+) ifconfig is deprecated. Instead use:
  <pre>ip -c addr show</pre>
</p>

Open a command terminal:
<figure>

<img src="images/terminal.png" alt="Terminal"/>
            <figcaption>Example Terminal</figcaption>
            </figure>
        <p>
Type: <i>ifconfig</i>
</p>
This should put out something like:
<pre>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
	options=3&lt;RXCSUM,TXCSUM&gt;
	inet6 ::1 prefixlen 128
	inet 127.0.0.1 netmask 0xff000000
	inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1
	nd6 options=1&lt;PERFORMNUD&gt;
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
stf0: flags=0&lt;&gt; mtu 1280
en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	ether a4:5e:60:e7:21:0f
	inet6 fe80::a65e:60ff:fee7:210f%en0 prefixlen 64 scopeid 0x4
	inet 172.20.152.14 netmask 0xfffff000 broadcast 172.20.159.255
	nd6 options=1&lt;PERFORMNUD&gt;
	media: autoselect
	status: active
en1: flags=963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX&gt; mtu 1500
	options=60&lt;TSO4,TSO6&gt;
	ether 6a:00:00:41:c6:f0
	media: autoselect &lt;full-duplex&gt;
	status: inactive
en2: flags=963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX&gt; mtu 1500
	options=60&lt;TSO4,TSO6&gt;
	ether 6a:00:00:41:c6:f1
	media: autoselect &lt;full-duplex&gt;
	status: inactive
bridge0: flags=8822&lt;BROADCAST,SMART,SIMPLEX,MULTICAST&gt; mtu 1500
	options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt;
	ether a6:5e:60:7e:1d:00
	Configuration:
		id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0
		maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200
		root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0
		ipfilter disabled flags 0x2
	member: en1 flags=3&lt;LEARNING,DISCOVER&gt;
	        ifmaxaddr 0 port 5 priority 0 path cost 0
	member: en2 flags=3&lt;LEARNING,DISCOVER&gt;
	        ifmaxaddr 0 port 6 priority 0 path cost 0
	media: &lt;unknown type&gt;
	status: inactive
p2p0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2304
	ether 06:5e:60:e7:21:0f
	media: autoselect
	status: inactive
awdl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1484
	ether ca:90:43:20:19:ba
	inet6 fe80::c890:43ff:fe20:19ba%awdl0 prefixlen 64 scopeid 0x9
	nd6 options=1&lt;PERFORMNUD&gt;
	media: autoselect
	status: active
vboxnet0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
	ether 0a:00:27:00:00:00
	inet 192.168.59.3 netmask 0xffffff00 broadcast 192.168.59.255
vboxnet1: flags=8842&lt;BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	ether 0a:00:27:00:00:01
</pre>
You are most likely to be looking for the bridge100 interface:
<pre>
bridge100: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	options=3&lt;RXCSUM,TXCSUM&gt;
	ether a6:5e:60:7e:1d:64
	inet 192.168.2.1 netmask 0xffffff00 broadcast 192.168.2.255
	inet6 fe80::a45e:60ff:fe7e:1d64%bridge100 prefixlen 64 scopeid 0xe
	Configuration:
		id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0
		maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200
		root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0
		ipfilter disabled flags 0x2
	member: en4 flags=3&lt;LEARNING,DISCOVER&gt;
	        ifmaxaddr 0 port 10 priority 0 path cost 0
	Address cache:
	nd6 options=1&lt;PERFORMNUD&gt;
	media: &lt;unknown type &gt;
	status: inactive
    </pre>

This is the IP address 192.168.2.1 (line beginning with inet above.)
<p>
There are two ways to find out what is connected:
the first is to run the command <i>arp</i>.
</p>
<pre>
 arp -i bridge100 -a
</pre>
This runs a program which returns information about what is connected currently to that interface.

Command Breakdown:
<pre> arp - program to run

-i value - use the interface value
-a - display all current connections
</pre>
When you run this command you will get output which contains lines like:
<pre>
? (239.255.255.250) at 1:0:5e:7f:ff:fa on bridge100 ifscope permanent [ethernet]
</pre>
        <p>
            Running the arp program will give you a list of connected IP addresses on your Bridge100 interface, this list of addresses is the list of Raspberry Pi addresses - there should be the same number of addresses as you have Raspberry Pis connected.
        </p>
<p>
The other way is to install a program like nmap, which is available from <a href="https://nmap.org/">https://nmap.org/</a>.
</p>
       <p> To run nmap to scan on your network you can do it in two ways:</p>
        <ul>
            <li>Scan a range of IP addresses: <pre> nmap 192.168.2.1-255</pre>
            Use this option if you know what range your connection sharing will use; replace the IP address range with your own values.</li>
            <li>Scan a subnet on the network: <pre>nmap 192.168.2.0/24</pre>
            Use this option if you only know the start of the IP address range (e.g. 192.168.2) and it will scan over the whole subnet.</li>
        </ul>

        <h4> <a name="winnmap">Windows</a> </h4>
 <p>
Install Nmap (available at <a href="https://nmap.org/">https://nmap.org/</a>) if you are using Windows - this is the easiest way to determine the IP addresses. Using the Ethernet IP address you noted before when sharing the Internet Connection, run the command, replacing the IP address with yours but change the last number to 0:

</p>
            <pre>
c:\nmap 192.168.137.0/24
     </pre>
    <p>This should give output like:</p>
        <pre>
C:\>nmap 192.168.137.0/24

Starting Nmap 7.40 ( https://nmap.org ) at 2017-04-26 15:53 GMT Daylight Time
Nmap scan report for 192.168.137.225
Host is up (0.00013s latency).
All 1000 scanned ports on 192.168.137.225 are closed
MAC Address: 98:5A:EB:C7:15:8B (Apple)

Nmap scan report for 192.168.137.1
Host is up (0.0013s latency).
Not shown: 997 closed ports
PORT    STATE SERVICE
135/tcp open  msrpc
139/tcp open  netbios-ssn
445/tcp open  microsoft-ds

Nmap done: 256 IP addresses (2 hosts up) scanned in 23.48 seconds

C:\>
        </pre>
        <p>All the IP addresses which show up starting with Nmap scan report for IP address will be your Raspberry Pis - except for the one with your written down IP address.</p>
        <p>
Now we know what IP addresses are assigned to the Pis.
</p>
        <p>
IP addresses are what we can use to identify a Pi on the network and use it as a target to log in - its the same as a street address when going somewhere - though IP addresses can change.

A brief explanation of IP Addresses and DHCP are available at the following links:
            </p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/IP_address">IP Address</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">DHCP</a></li>
</ul>


    <p>
Now we have our Pis started, we know their current IP addresses - now we should start doing some configuration and setup.
        <b>Note: These IP addresses are only valid with the current connection to your computer. After the setup is complete, the Raspberry Pis will be assigned addresses by the cluster server.</b>
</p>
    <p>
For example, my Pi addresses are:
           </p>
    <pre>
192.168.2.18
192.168.2.19
192.168.2.20
192.168.2.21
192.168.2.22
</pre>
        <p>
I am going to make the Pi with address 192.168.2.18 the master node in the cluster and the other Pis will be worker nodes.
    </p>
        <p>
The master node in our clusters will run the network assigning IP addresses via the DHCP server, share its Wifi connection (if used), share a networked drive for files and start the programs we will run on the cluster.
               </p>
        <p>
The worker nodes will do the actual computation in any programs.
</p>
    <a name="mainnode"><h2>Setting Up the Main Node</h2></a>

<p>
We will start with the master node.
</p>
        <p>
In your command terminal type the following command, replacing the 192.168.2.18 with your IP address for your Pi:
        </p>
<pre>
ssh pi@192.168.2.18
</pre>
        <p>
You will get output like this coming up:
        </p>
    <pre>
The authenticity of host '192.168.2.18 (192.168.2.18)' can't be established.
RSA key fingerprint is a0:97:1f:d6:df:8c:a5:45:db:fe:b4:94:46:1d:0f:48.
Are you sure you want to continue connecting (yes/no)?
</pre>
        <p>
Type yes in and the following will appear:
            </p>
<pre>
Warning: Permanently added '192.168.2.18' (RSA) to the list of known hosts.
pi@192.168.2.18's password:
</pre>
        <p>
Type in the password: <i>raspberry</i>
</p>
        <p>
Now you have logged into your new master node for your cluster.
</p>
        <p>
To breakdown what happened, you typed in
            </p>
        <pre>ssh pi@192.168.2.18</pre>
<p>
This is a command which runs the ssh client on your computer and tries to connect to a system at address 192.168.2.18 with the user name pi. This is a standard way of logging into a remote system - like a supercomputer such as ARCHER.
</p>
        <p>
You will then get output like:
</p>
    <pre>
The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.


Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Fri Feb 26 03:25:51 2016
pi@raspberrypi:~ $
</pre>
<p>
<a name="configrpi">Let's do some main system configuration</a>:
</p>
        <p>
Type the command  sudo raspi-config and press Enter/Return, e.g.:
        </p>
<pre>
pi@raspberrypi:~ $ sudo raspi-config
</pre>
        <p>
This will run a provided Raspberry Pi configuration program.
            </p>
<p>
The sudo command means that any following commands will be run as the super-user which has permissions to make system changes rather than just changes in a user own files.
</p>
        <p>
When a menu appears:
        </p>
<ul>
<li>Choose option 3 Boot Options.</li>
<li>Now choose option B1 Text console and hit enter/return.</li>
</ul>
        <p>
This will mean that the Raspberry Pi will always boot to a command line rather than a GUI (that is a Graphical User Interface which is what we normally use in everyday use of computers).
        </p>
<ul>
<li>Now choose the option 9 Advanced Options.</li>
<li>Choose the Option A2 Hostname and hit enter/return.</li>
        </ul>
        <p>
An information screen will appear - read it before continuing.
</p>
<p>On this screen, there is a hostname, an easy to recognise name, for the Raspberry Pi you are logged into. To make it more identifiable and customise your cluster, you can choose a name for the Raspberry Pi you are logged into.
        </p>
        <p>
In my example I will change it to <i>beira</i> and hit enter/return to confirm it.
        </p>

<p>
We need to set the right time zone so that the date and time on the Pi is correct.
        </p>
<ul>
    <li>Choose Option 5 Internationalisation Options.</li>
<li>Choose the T2 Change Timezone option.</li>
  <li>  From the list choose your area, for me it is Europe.</li>
    <li>Then choose your closest location, I chose London.</li>
        </ul>

<p>
Once back in the main menu, use the cursor/arrow keys to move to the button which says Finish and hit enter/return.
          </p>
        <p>
It will ask if you want to reboot - choose yes and reboot this Pi.
  </p>
    <p>
Your ssh session with the Raspberry Pi will end. The Raspberry Pi will take a little time to reboot before you can log in again to continue. Have patience here.
  </p>
        <p>
Now log back into the Raspberry Pi using the ssh command previously used and put in the password.
  </p>
        <p>
Now you will note that the command line says pi@your-hostname-here so my example shows
  </p>
    <pre>
pi@beira:~ $
</pre>
        <p>
We will now install some updates on the Raspberry Pi main software. The first command to run is rpi-update.
          </p>
<pre>
pi@beira:~ $ sudo rpi-update
</pre>
        <p>
This will update the Raspberry Pi with the latest version of the core software and firmware for the system - it will take a few minutes and start with output like:
  </p>
        <pre>
 *** Raspberry Pi firmware updater by Hexxeh, enhanced by AndrewS and Dom
 *** Performing self-update
 *** Relaunching after update
 *** Raspberry Pi firmware updater by Hexxeh, enhanced by AndrewS and Dom
#############################################################
WARNING: This update bumps to rpi-4.9.y linux tree
Be aware there could be compatibility issues with some drivers
Discussion here:
https://www.raspberrypi.org/forums/viewtopic.php?f=29&t=167934
##############################################################
Would you like to proceed? (y/N)
</pre>
        <p>
If you do not want to perform this update, choose <i>N</i>, otherwise type <i>y</i>. You will need to reboot the Raspberry Pi for this to take effect.
          </p>
    <pre>
pi@beira:~ $ sudo reboot
</pre>
<p>
This will take a little time.
</p>
        <p>
So far what has been done:
            </p>
<ul>
<li>The hardware and cables have been connected together.</li>
<li>We shared our internet connection.</li>
<li>We chose a master node and logged into it.</li>
<li>We chose a hostname and updated the core software.</li>
</ul>
        <p>
Now log back into the node you are working on.
</p>
        <p>
Before we run any more software updates or install new software we will begin to setup the passwordless login system that the cluster will need to run programs.
</p>
        <p>
At the command line run the following:
        </p>
    <pre>
pi@beira:~ $ ssh-keygen -t rsa
</pre>
        <p>
This will generate what is called a public/private key pair - this is a system used for encryption and security to allow information to be shared in private. This will generate a public file which can be given to any other machine or person you want to communicate with and a private file which has to be kept secret so that other people know that only you sent information to them or the information they send to you using your public key can only be read by you.
</p>
        <p>
Use the default settings for the first prompt and don’t put in a passphrase for this cluster (just press return/enter when you are asked for a pass phrase).
Your interaction should look a little like:
        </p>
    <pre>
pi@beira:~ $ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/pi/.ssh/id_rsa):
Created directory '/home/pi/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/pi/.ssh/id_rsa.
Your public key has been saved in /home/pi/.ssh/id_rsa.pub.
The key fingerprint is:
9b:98:c7:86:17:0a:1e:32:95:65:ee:1c:0f:48:48:ef pi@beira
The key's randomart image is:
+---[RSA 2048]----+
| .... o          |
|  .o *           |
|    = +          |
|   o o +         |
|  o E o S        |
|   + o * +       |
|    . = B        |
|       +         |
|                 |
+-----------------+
pi@beira:~ $
</pre>
        <p>
You’ve set up a ssh key - remember how to do this as you will be doing it again later. Now we will update some of the operating system and installed software, run the command:
            </p>
<pre>
sudo apt-get update
    </pre>
        <p>
This will pull information about the latest versions of packages available for the Raspberry Pi operating system. It will take about 30-50 seconds to run.
</p>
        <p>
Now we will run:
        </p>
<pre>
sudo apt-get upgrade
</pre>
        <p>
This will upgrade the installed software to its latest versions - which should include bug fixes and improvements.
</p>
        <p>
When the prompt asks enter ‘Y’ and it will install the upgrades.
</p>
    <p>
Depending on the number of upgrades it could take a long period of time to run this command.
</p>
        <p>
Once the update has finished, we will start to set up the Network File System (NFS) server component.
</p>
        <p>
First thing we want to do is to add a network module, so run the following command:
        </p>
<pre>
sudo nano /etc/modules
</pre>
        <p>
This should open up a file like this:
        </p>
      <figure>
<img src="images/nanomodules.png" alt="Text Editor"/>
            <figcaption>Adding ipv6</figcaption>
            </figure>
<p>
at the end of the file, using the cursor keys to move,  if it is not present, add the following:
</p>
        <pre>
ipv6
</pre>
<ul>
   <li> Now press the keys CRTL and O at the same time - this will save the file.</li>
    <li>Now press the keys CRTL and X at the same time - this will close nano.</li>
</ul>
<p>
<b>Note:</b> nano is a simple text editor program that we will be using during this configuration process.
</p>
<p>
Run the command:
    </p>
<pre>
sudo service rpcbind start
</pre>
        <p>
Now we will install the NFS Kernel server - this is needed to run the server for the NFS drive.
</p>
        <pre>
sudo apt-get install nfs-kernel-server
</pre>
        <p>
Now we will start to create the actual shared location. Start by creating a directory in /home for sharing
        </p>
<pre>
sudo mkdir -p /home/shared_dir
</pre>
        <p>
<i>mkdir</i> is a command used to create a directory (which can contain other directories and files).
</p>
        <p>
Now change its access permissions so that everyone can read or write to this directory:
        </p>
<pre>
sudo chmod 777 /home/shared_dir
</pre>
        <p>
            <i>chmod</i> is a command to change the access permissions on a file or directory. Here 777 means that everyone can read, write or execute commands in that directory. If you only want the owner to be able to write and others to only read you would use 644. This link will take you to the <a href="https://en.wikipedia.org/wiki/Chmod">Wikipedia chmod entry</a>.
</p>
        <p>
Now we need to mount the shared_dir and bind it.
        </p>
    <pre>
sudo mount --bind /home/shared_dir/ /home/shared_dir/
</pre>
        <p>
This means that the system recognises this as something which is a mountable drive in the system - so that it can share it to other computers.
</p>
        <p>
Now we need to make sure the directory gets mounted and exported each time when the system boots up and that other computers can access it.
</p>
        <p>
Run the following command:
</p>
    <pre>
sudo nano /etc/fstab
</pre>
        <p>
at the end of the file add the following:
        </p>
    <pre>
/home/shared_dir  /home/shared_dir   none   bind  0 0
    </pre>
<ul>
   <li> Now press the keys CRTL and O at the same time - this will save the file.</li>
    <li>Now press the keys CRTL and X at the same time - this will close nano.</li>
</ul>
        <p>
To continue the configuration, run:
        </p>
    <pre>
sudo nano /etc/default/nfs-kernel-server
</pre>
        <p>
Make sure that one of the following options is present in the opened file:
          </p>
<pre>
NEED_SVCGSSD=no
</pre>
        <p>
or
      </p>
    <pre>
NEED_SVCGSSD=“no”
    </pre>
        <p>
or
  </p>
    <pre>
 NEED_SVCGSSD=“”
    </pre>
        <p>
or
  </p>
    <pre>
 NEED_SVCGSSD=
    </pre>

<ul>
   <li> Now press the keys CRTL and O at the same time - this will save the file.</li>
    <li>Now press the keys CRTL and X at the same time - this will close nano.</li>
</ul>
        <p>

The configuration process continues with a mapping file, run:
        </p>
    <pre>
sudo nano /etc/idmapd.conf
</pre>
        <p>
Ensure that under the [Mapping] section the following is present:
         </p>
    <pre>
[Mapping]

Nobody-User = nobody
Nobody-Group = nogroup
</pre>
        <p>
Now run the following to expose the new directory to the network:
     </p>
    <pre>
    sudo nano /etc/exports
</pre>
        <p>
At the end of the file add the following to export your shared_dir to the network:
         </p>
    <pre>
/home/shared_dir 192.168.2.0/24(rw,nohide,insecure,no_subtree_check,async)
</pre>
        <p>
This line will expose your shared_dir to the network where all the addresses start 192.168.2 and allow read and write acess. You can use the following command to reload the file now it's been modified:
         </p>
<pre>
exportfs -a
</pre>
<p>
As a final check on this we will examine the following files:
         </p>
    <pre>
/etc/init.d/nfs-kernel-server
/etc/init.d/nfs-common
/etc/init.d/rpcbind
</pre>
        <p>
Have a look at each of the above files in nano. Each one, near the top of the file, should have a line:
         </p>
    <pre>
# Default-Start:     2 3 4 5
</pre>
        <p>
            <b>however</b> in some this may say:
     </p>
    <pre>
# Default-Start:     S
</pre>
        <p>
You need to change all the files that have an S to 2 3 4 5 and then run:
        </p>
    <pre>
sudo update-rc.d -f rpcbind remove
sudo update-rc.d rpcbind defaults

sudo update-rc.d -f nfs-common remove
sudo update-rc.d nfs-common defaults

sudo update-rc.d -f nfs-kernel-server remove
sudo update-rc.d nfs-kernel-server defaults
</pre>
    <p>
If any of these commands fail with error messages, try the following:
         </p>
<pre>
sudo apt-get purge rpcbind
sudo apt-get install nfs-kernel-server
</pre>
        <p>
and try to do the above update again for any of the operations that failed.
</p>

     <p>
Before we go into setting up a DHCP server we will setup MPI. MPI is a core technology used in parallel and high performance computing that allows processes to communicate in a standard way and thus allows them to collaborate to solve a problems together in parallel. We will install and test a simple program on a single node.
</p>
        <p>
Run the following:
        </p>
<pre>
sudo apt-get install libxml2-dev
sudo apt-get install zlib1g zlib1g-dev
sudo apt-get install mpich
</pre>
        <p>
Now try running the command:
        </p>
<pre>
mpiexec —version
</pre>
        <p>
You should get output looking something like:
        </p>
    <pre>
      pi@beira:~ $ mpiexec --version
      HYDRA build details:
          Version:                                 3.2
          Release Date:                            Wed Nov 11 22:06:48 CST 2015
          CC:                              gcc   -Wl,-z,relro
          CXX:                             g++   -Wl,-z,relro
          F77:                             gfortran  -Wl,-z,relro
          F90:                             gfortran  -Wl,-z,relro
          Configure options:                       ...
          Process Manager:                         pmi
          Launchers available:                     ssh rsh fork slurm ll lsf sge manual persist
          Topology libraries available:            hwloc
          Resource management kernels available:   user slurm ll lsf sge pbs cobalt
          Checkpointing libraries available:       blcr
          Demux engines available:                 poll select

    </pre>
        <p><b>Note:</b> The output above has been truncated so when the command is run the output will have more details.</p>
        <p>
Now we will write a small program to test that MPI works on our one Raspberry Pi.
        </p>
        <p>
Type the following commands which will change us to the shared_dir directory, where we will create a new directory, change into that directory, create a text file with the code content, compile the resulting program and run it.
         </p>
<pre>
cd /home/shared_dir
mkdir testprogram
cd testprogram
nano hello.c
</pre>
        <p>
Type the following:
         </p>
<pre>
#include &lt;mpi.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char** argv) {
    // Initialize the MPI environment
    MPI_Init(NULL, NULL);

    // Get the number of processes
    int world_size;
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

    // Get the rank of the process
    int world_rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

    // Get the name of the processor
    char processor_name[MPI_MAX_PROCESSOR_NAME];
    int name_len;
    MPI_Get_processor_name(processor_name, &name_len);

    // Print off a hello world message
    printf("Hello world from processor %s, rank %d"
           " out of %d processors\n",
           processor_name, world_rank, world_size);

    // Finalize the MPI environment.
    MPI_Finalize();
}
</pre>
    <p>
Now save the file and exit nano.
        </p>
        <p>
Type the following to compile the code:
         </p>
<pre>
mpicc -o hello hello.c
</pre>
        <p>
Type the command:
         </p>
<pre>
ls -al
</pre>
        <p>
This should show the directory contents - which will include an executable file called hello.
     </p>
        <p>
Now we will run this as an MPI program.
 </p>
        <p>
First we need to create a hostfile:
         </p>
<pre>
nano hostfile
</pre>
        <p>
where you need to type in the address of <b>your</b> Raspberry Pi followed by a :<i>:4</i>", for example I need to type in:
         </p>
<pre>
192.168.2.18:4
</pre>
        <p>
Now save the file and exit nano.
 </p>
        <p>
To run the hello program type in the command:
         </p>
<pre>
mpiexec -n 4 -f hostfile ./hello
</pre>
        <p>
The mpiexec command will run the program hello as an MPI program across 4 cores on the systems identified in your hostfile. This means that the program will run as four processes which can communicate with each other - in this case each process will only write out which core on the Raspberry Pi it is working on.
 </p>
        <p>
You should get output like this:
         </p>
<pre>
pi@beira:/home/shared_dir/testprogram $ mpiexec -n 4 -f hostfile ./hello
Hello world from processor beira, rank 0 out of 4 processors
Hello world from processor beira, rank 1 out of 4 processors
Hello world from processor beira, rank 2 out of 4 processors
Hello world from processor beira, rank 3 out of 4 processors
</pre>
        <p>
If you see this output like this then congratulations - you have setup MPI on your system and run a basic MPI program on it. This is the first step in checking that things are working correctly.
        </p>
        <p>
To enable Wifi on this main node, you need to add a network to the wpa_supplicant.conf file.
        </p>
        <p>
Type the command:
        </p>
<pre>
sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
</pre>
        <p>
at the end of the file add:
         </p>
<pre>
network={
    ssid=“&lt;your ssid&gt;“
    psk=“&lt;your wifi code&gt;“
}
</pre>
        <p>
            <b>Note: The SSID is the WiFi network identifier - this is an identifier broadcast to allow you to select the right WiFi network. If you are running a home network - this will likely be on your router. Otherwise you can check to see what WiFi network your main computer is connected to from the WiFi network properties.</b><br/>
As an example:
         </p>
<pre>
network={
    ssid="SKY64DBE"
    psk="UDAXEESQ"
}
</pre>
        <p>
        If you have a system like <i>eduroam</i> please see the blog article: <a href="https://www.epcc.ed.ac.uk/blog/2016/04/29/getting-wee-archie-net">Eduroam Networking</a>.
 </p>
        <p>
You may need to restart the wifi connection on your Raspberry Pi. Run the command:
         </p>
<pre>
sudo ifdown wlan0
</pre>
        <p>
Wait for a few second then run:
         </p>
<pre>
sudo ifup wlan0
</pre>
        <p>
if you run the command:
         </p>
<pre>
ifconfig wlan0
</pre>
        <p>
You should get the output for the wifi with an IP address. Sharing this connection will be done after the next part.
 </p>
<p>
Now what we need to do is setup a DHCP server on this node - this will serve IP addresses to any other machine that wants to connect to its network and asks for one.
 </p>
     <p>
        First we will install <i>dnsmasq</i>, to do this run the command:
          </p>
<pre>
sudo apt-get install dnsmasq
</pre>
        <p>
Once it is installed, we will need to configure the dhcp server, type:
        </p>
<pre>
sudo nano /etc/dnsmasq.conf
</pre>
        <p>
This will open the configuration file for dnsmasq.
 </p>
        <p>
        Press CRTL and W which will start a search, type in <i>domain-needed</i> and press enter/return.
         </p>
        <p>
        Remove the # from the beginning of that line  (a # is a comment and tells the program to ignore the rest of the line, good for documenting your own changes).
         </p>
        <p>
        Also remove the # from the line that has bogus-priv.
 </p>
        <p>
Find the line beginning server=/ (ignore lines starting with #) and change the line to read:
 </p>
<pre>
server=/cluster/&lt;ip address of your main node&gt;
</pre>
        <p>
so, for example I would use:
 </p>
<pre>
server=/cluster/192.168.2.18
</pre>
        <p>
Now find the line starting with local=/ and change it to:
 </p>
    <pre>
local=/cluster/
</pre>
        <p>
Search for expand-hosts.
 </p>
        <p>
Remove the # from the beginning of that line.
 </p>
Goto the line starting:
<pre>
#domain=
</pre>
        <p>
and change this to:
 </p>
<pre>
domain=cluster
</pre>
        <p>
Now goto the first line: #dhcp-range=
 </p>
        <p>
Remove the # and change it to:
     </p>
<pre>
dhcp-range=192.168.2.30,192.168.2.100,14d
</pre>
<p>
This will set the range of IP addresses that can be assigned to client machines (192.168.2.30-192.168.2.100) and for how long they are assigned those addresses before they are renewed, known as lease time, in this case 14 days.
        </p>
        <p>
Save this file now and exit the editor.
 </p>
        <p>
Run the following command:
         </p>
<pre>
sudo nano /etc/resolv.conf
</pre>
        <p>
At the end of the file add <i>nameserver &lt;ip address of your main node&gt;</i>, for example:
         </p>
<pre>
nameserver 192.168.2.18
</pre>
        <p>
Now save and exit.
        </p>
        <p>
Then run:
        </p>
<pre>
sudo nano /etc/hosts
</pre>
        <p>
at the end of the file add <i>&lt;ip address of your main node&gt; &lt;hostname of your main node&gt;</i>, for example:
        </p>
<pre>
192.168.2.18   beira
</pre>
        <p>
Then save and exit.
        </p>
<p>
Now we will fix the IP address of this Raspberry Pi - so that it is a fixed point we will always know.
        </p>
          <p>There are two tested versions of Raspbian for these instructions - "Wheezy" and "Jessie". New installations of Raspbian should be "Jessie" - commonly Raspberry Pi 3 computers, older Raspberry Pi 1 and 2 will if not upgraded likely be running "Wheezy". Use the instructions for your particular installation.</p>

<h3>Network Configuration: Raspberry Pi "Wheezy"</h3>
<<<<<<< HEAD
      <p>
=======
        <p>There are two tested versions of Raspbian for these instructions - "Wheezy" and "Jessie". New installations of Raspbian should be "Jessie" - commonly Raspberry Pi 3 computers, older Raspberry Pi 1 and 2 will, if not upgraded, likely be running "Wheezy". Use the instructions for your particular installation.</p>
        <p>
>>>>>>> 6b79860ef9df268aa649fc8127c9878cb1b5a24b
For Raspberry Pi running the Raspbian version denoted "Wheezy" (commonly non-upgraded Raspberry Pi 1 and 2) do the following:
        </p>
<pre>
sudo nano /etc/network/interfaces
</pre>
        <p>
in that file there will be a line:
           </p>
<pre>
iface eth0 net manual
</pre>
        <p>
we will change this to use  a static IP address.

replace the line with
                   </p>
<pre>
iface eth0 inet static
address 192.168.2.18
netmask 255.255.255.0
network 192.168.3.0
broadcast 192.168.2.255
gateway 192.168.2.1
</pre>
        <p><b>Note:</b> Use the IP Address of your node in place of my example 192.168.2.18.</p>
<p>
        Save this file and exit now.
       </p>
        <p>
        Now start the service and reboot:
        </p>
        <pre>
sudo service dnsmasq start
sudo reboot
</pre>
<p>
Then log back into the Raspberry Pi.
  </p>
<h3>Network Configuration: Raspberry Pi "Jessie"</h3>
For Raspberry Pi computers running Raspbian version denoted "Jessie" (commonly Raspberry Pi 3), run:
    <pre>
    sudo nano /etc/dhcpcd.conf
</pre>
        <p>
At the bottom of the file add:
          </p>
<pre>
interface eth0

static ip_address=192.168.2.18/24
</pre>
<p>
Now start the service and reboot:
          </p>
<pre>
sudo service dnsmasq start
sudo reboot
</pre>
   <p>
Then log back into the Raspberry Pi.
  </p>

   <h3>On All Systems</h3>
        <p>
If you disable the internet sharing on your laptop/desktop you will find that you get an IP address from the Pi on the ethernet.
  </p>
        <p>
If you have configured wifi to connect to your internet, you can share this across the network being served by the Raspberry Pi via its ethernet connection.
  </p>
        <p>
On the host Raspberry Pi run:
          </p>
<pre>
 sudo nano /proc/sys/net/ipv4/ip_forward
</pre>
        <p>
Change the value 0 to 1, then save and exit.
</p>
        <p>
Then run:
        </p>
<pre>
sudo iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
</pre>
        <p>
This will share the connection across any machines getting IP addresses from this Pi.
</p>
        <p>
However if you reboot the Pi, this sharing will be lost.
</p>
        <p>
What we need to do is make the iptables persistent and the forwarding permanent.
</p>
        <p>
To do this run:
        </p>
<pre>
sudo nano /etc/sysctl.conf
</pre>
        <p>
For the line #net.ipv4.ip_forward=1 remove the #.
</p>
        <p>
Now run the following commands to make the iptables changes load each time:
        </p>
<pre>
sudo iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE
sudo apt-get install iptables-persistent
</pre>
        <p>
When it asks you if you want to save the current configuration, say yes both times.
</p>
        <p>
This will add the wifi sharing as a permanent feature of your cluster.
</p>
        <p>
Now you have made changes to your main node which will do the following:
        </p>
<ul>
<li>Share a network drive.</li>
<li>Run a DHCP Server.</li>
<li>Run an MPI program.</li>
<li>Share Internet Connections.</li>
</ul>


<a name="workers"><h3>Setting up the worker nodes</h3></a>
        <p>
Now what we need to do is configure the worker nodes.
</p>
<p>
First we need to know what addresses they have - if you are continuing to use internet sharing from a laptop/desktop use the instructions from  <a href="#sharing">earlier.</a>
</p>
<p>
If you are sharing from your new master node, then you can find out the ip addresses like this:
</p>

    <pre>
less /var/lib/misc/dnsmasq.leases
</pre>
        <p>
This will list the connected machines to the master node.
</p>
<p>
One of these will be your laptop/desktop.
        </p>

<pre>
1471486087 b8:27:eb:1d:52:f6 192.168.2.55 raspberrypi 01:b8:27:eb:1d:52:f6
1471486084 b8:27:eb:47:a1:27 192.168.2.39 * 01:b8:27:eb:47:a1:27
1471486081 b8:27:eb:cf:a3:29 192.168.2.62 * 01:b8:27:eb:cf:a3:29
1471486081 b8:27:eb:0c:4d:4e 192.168.2.72 * 01:b8:27:eb:0c:4d:4e
1471482976 34:15:9e:07:d4:42 192.168.2.47 Khonsu 01:34:15:9e:07:d4:42
</pre>
        <p>
You will notice some of the lines have a "*" - this is because all the worker nodes have the same hostname which doesn’t really work on a network. Your laptop or desktop should have a name, in my example it is Khonsu.
</p>
<p>
We are going to do a manual configuration change to fix this, but we could write a script to run on all our nodes so that we don’t have to type a lot ourselves. If this is not the first time you have created a cluster, you can create a script, if it is the first time it may be more reassuring to do it yourself.
</p>
<p>
So on each node you need to login:
        </p>

<pre>
ssh pi@&lt;address&gt;
</pre>
        <p>
You will get the ssh certificate warning which you can ignore, then you will need to type your password in.
</p>
<p>
    Once logged in - you will need to run the raspi-config again and choose the same settings options as you did for the master node - just with a different hostname and remember to set the timezone - <a href="#configrpi" >see the main system configuration</a>. Here is the list of raspi-config steps:

    <ul>
<li>Choose option 3 Boot Options.</li>
<li>Now choose option B1 Text console and hit enter/return.</li>
<li>Now choose the option 9 Advanced Options.</li>
<li>Choose the Option A2 Hostname and hit enter/return.</li>
  <li>Set Hostname</li>
    <li>Choose Option 5 Internationalisation Options.</li>
<li>Choose the T2 Change Timezone option.</li>
  <li>  From the list choose your area, for me it is Europe</li>
    <li>Then choose your closest location, I chose London.</li>
        </ul>
        </p>
        <p>
For my example, I will just call them worker01-worker04 so if I look at the leases in dnsmasq:
        </p>
    <pre>
1471486724 b8:27:eb:1d:52:f6 192.168.2.55 worker01 01:b8:27:eb:1d:52:f6
1471486758 b8:27:eb:47:a1:27 192.168.2.39 worker02 01:b8:27:eb:47:a1:27
1471486815 b8:27:eb:cf:a3:29 192.168.2.62 worker03 01:b8:27:eb:cf:a3:29
1471486841 b8:27:eb:0c:4d:4e 192.168.2.72 worker04 01:b8:27:eb:0c:4d:4e
1471482976 34:15:9e:07:d4:42 192.168.2.47 Khonsu 01:34:15:9e:07:d4:42
</pre>
        <p>
I can login to the nodes with their IP Address now if the configuration of the server has worked correctly.
</p>
        <p>
You will need to generate an ssh key with ssh-keygen for each machine.
</p>
        <p>
Now you will have four workers each with their own ssh keys.
</p>
        <p>
Now you will have to update them all.
</p>
        <p>
You can open up multiple terminals and on each worker run the following command:
        </p>
    <pre>
sudo rpi-update
</pre>
        <p>
This means all the workers are updating at the same time.
</p>
        <p>
Once the update has completed - you will need to reboot.
</p>
        <p>
To save a lot of typing - what we will do is set up passwordless login within the cluster - we need this for parallel programs to work and it saves us time as well.
</p>
        <p>
First we will set up passwordless login from the master node to the worker node.
            </p>
        <p>
Log into the master node and then for each of your workers run the following:
        </p>
    <pre>
ssh-copy-id pi@&lt;worker node&gt;
</pre>
        <p>
Each time you will need to enter a password.
</p>
        <p>
Now you will need to do this on each of the workers - doing an ssh-copy-id to all the other nodes.
</p>
        <p>
Now that will take a little time to type in but it will save time in the future.
</p>

        <p>
On each worker run:
        </p>
<pre>
sudo nano /etc/hosts
</pre>
        <p>
At the end of the file add:
        </p>
<pre>
&lt;ip address of your server node&gt; &lt;name of your server&gt;
</pre>
    <p>
for my example:
    </p>
<pre>
192.168.2.18 beira
</pre>
            <p>
Now we need to update the OS on each worker.
</p>
        <p>
Run the command:
        </p>
    <pre>
sudo apt-get update && sudo apt-get upgrade
</pre>
        <p>
You will need to confirm on each worker that you want the install to continue.
</p>
        <p>
This will take some time to install even if they are all going at the same time.
</p>
        <p>
After they are updated we need to install some additional packages:
        </p>
<pre>
sudo apt-get install libxml2-dev
sudo apt-get install zlib1g zlib1g-dev
sudo apt-get install mpich
</pre>
          <p>
Now you should be able to run:
        </p>

    <pre>
mpiexec —version
</pre>
<p>
However, we are not quite finished with the software setup. We need to setup the mounted shared drive.
</p>
        <p>
Start on each node by doing this:
        </p>
    <pre>
sudo mkdir /home/shared_dir
sudo chmod 777 /home/shared_dir/
</pre><p>
ON each node run:
        </p>
    <pre>
sudo apt-get purge rpcbind
sudo apt-get install nfs-common
</pre><p>
You will need to do this on each node:
        </p>
    <pre>
/etc/init.d/nfs-common
/etc/init.d/rpcbind
</pre>
        <p>
Have a look at the above files in nano.
</p>
        <p>
Each file should have a line near the top with:
        </p>
    <pre>
# Default-Start:     2 3 4 5
</pre>
        <p>
However, as before, in some it may have:
        </p>
    <pre>
# Default-Start:     S
</pre>
        <p>
Change all the S to 2 3 4 5.
</p>
        <p>
Then run:
    <pre>
sudo update-rc.d -f rpcbind remove
sudo update-rc.d rpcbind defaults

sudo update-rc.d -f nfs-common remove
sudo update-rc.d nfs-common defaults
</pre>
        <p>
We are going to address the shared nfs drive by its IP address:
        </p>

<pre>
sudo mount 192.168.2.18:/home/shared_dir /home/shared_dir
</pre>
        <p>
This will only mount the drive a single time - when you reboot the Pi the changes will be lost.
</p>
        <p>
So we need to add it to some configuration that will do this automatically, run:
    </p>
    <pre>
sudo nano /etc/fstab
</pre><p>
at the end of the file add:
        </p>
    <pre>
192.168.2.18:/home/shared_dir /home/shared_dir nfs rw,hard,intr,noauto,x-systemd.automount 0 0
</pre>
        <p>
Now you can reboot everything so on each node run:
        </p>
    <pre>
sudo reboot
</pre>
        <p>
Now we will test our simple hello world across multiple nodes -
login to the master node:
        </p>
<pre>
cd /home/shared_dir/testprogram
nano hostfile
</pre>
        <p>
in the hostile add the IP addresses of your nodes (not the ones in the example unless they match up) with a :4 at the end like this:
        </p>
<pre>
192.168.2.18:4
192.168.2.72:4
192.168.2.55:4
192.168.2.39:4
192.168.2.62:4
</pre>
        <p>
Save and exit nano.
</p>
        <p>
Run the following command:
        </p>
<pre>
mpiexec -n 20 -f hostfile ./hello
</pre>
        <p>
and it should give output like:
        </p>
<pre>
Hello world from processor worker03, rank 16 out of 20 processors
Hello world from processor worker03, rank 17 out of 20 processors
Hello world from processor worker03, rank 18 out of 20 processors
Hello world from processor worker03, rank 19 out of 20 processors
Hello world from processor worker04, rank 4 out of 20 processors
Hello world from processor worker04, rank 5 out of 20 processors
Hello world from processor worker01, rank 8 out of 20 processors
Hello world from processor worker04, rank 6 out of 20 processors
Hello world from processor worker01, rank 9 out of 20 processors
Hello world from processor worker04, rank 7 out of 20 processors
Hello world from processor worker01, rank 10 out of 20 processors
Hello world from processor worker01, rank 11 out of 20 processors
Hello world from processor worker02, rank 12 out of 20 processors
Hello world from processor worker02, rank 13 out of 20 processors
Hello world from processor worker02, rank 14 out of 20 processors
Hello world from processor worker02, rank 15 out of 20 processors
Hello world from processor beira, rank 1 out of 20 processors
Hello world from processor beira, rank 3 out of 20 processors
Hello world from processor beira, rank 0 out of 20 processors
Hello world from processor beira, rank 2 out of 20 processors
</pre>
        <p>
Congratulations, if you got this then you have put together a basic cluster for running parallel programs on.
</p>

        <p>
To turn off  a Raspberry Pi, type:
        </p>
    <pre>sudo halt</pre>

     <p>
To see how fast your cluster is, the next instruction set will show you how to install a benchmark and how to run it.
</p>

<a name="bench"><h3>Running a benchmark</h3></a>
<p>
Linpack is a commonly used benchmark to test how “fast” a supercomputer can go. What we are going to do is install linpack on your cluster and test how fast your cluster is.
</p>

        <p>
The first thing to do is to log into your cluster and connect it to the internet.
</p>

        <p>
We are going to run the HPL - High Performance Linpack Benchmark on your cluster, more information on this can be found at <a href="http://www.netlib.org/benchmark/hpl/">Linpack</a>.
        </p>
<h4>Software Setup:</h4>
<p>
On each node, we need some additional software so run the following command on each of the nodes:
 </p>
    <pre>
 sudo apt-get install libatlas-base-dev gfortran
</pre>
        <p>
Now use the following command to change to the shared drive:
         </p>
<pre>
cd /home/shared_dir
</pre>
        <p>
Now, create a linpack directory:
         </p>
<pre>
mkdir linpack
cd linpack
</pre>
        <p>
Now download the HPL source:
         </p>
    <pre>
wget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz
</pre>
        <p>
This file is a compressed archive to make it quicker to download, we will now extract the archive:
        </p>
<pre>
tar xf hpl-2.2.tar.gz
</pre>
        <p>
Change into the new directory and into the setup directory:
         </p>
<pre>
cd hpl-2.2/setup
</pre>
        <p>
Run the following command:
         </p>
<pre>
sh make_generic
</pre>
        <p>
Change to the parent directory:

     </p>
    <pre>
cd ..
</pre>
        <p>
Copy the Make.UNKNOWN file and call it Make.rpi.
         </p>
<pre>
cp setup/Make.UNKNOWN Make.rpi
</pre>
        <p>
Now we will edit the file:
         </p>
<pre>
nano Make.rpi
</pre>
        <p>
Press CRTL+W and search for ARCH.
 </p>
        <p>
The line should say ARCH = UNKNOWN.
         </p>
<pre>
Change unknown to rpi
</pre>
        <p>
Search for TOPdir.
 </p>
Change the value for TOPdir to:
    <pre>
/home/shared_dir/linpack/hpl-2.2
</pre>
        <p>
We could set the first part of this to an environment variable but that is another topic.
 </p>
        <p>
A few lines below you will find three blank entries Mkdir, MPinc, MPlib.
 </p>
        <p>
Set these to the values shown below:
 </p>
    <pre>
MPdir        = /usr/lib
MPinc        = -I $(MPdir)/mpich/include
MPlib        = $(MPdir)/arm-linux-gnueabihf/libmpich.a

LAdir        = /usr/lib/atlas-base/
LAinc        = $(LAdir)/libf77blas.a $(LAdir)/libatlas.a
LALib        = -lblas

</pre>
        <p>
Save the file and exit nano, then type the command:
         </p>
<pre>
make arch=rpi
</pre>
        <p>
This will compile the benchmark.
 </p>
        <p>
Now we need to create a data file to test with:
     </p>
<pre>
cd bin/rpi
nano HPL.dat
</pre>
        <p>
Now enter the following text into the HPL.dat file:
         </p>
<pre>
HPLinpack benchmark input file
Innovative Computing Laboratory, University of Tennessee
HPL.out      output file name (if any)
6            device out (6=stdout,7=stderr,file)
1            # of problems sizes (N)
5040         Ns
1            # of NBs
128          NBs
0            PMAP process mapping (0=Row-,1=Column-major)
1            # of process grids (P x Q)
1            Ps
1            Qs
16.0         threshold
1            # of panel fact
2            PFACTs (0=left, 1=Crout, 2=Right)
1            # of recursive stopping criterium
4            NBMINs (>= 1)
1            # of panels in recursion
2            NDIVs
1            # of recursive panel fact.
1            RFACTs (0=left, 1=Crout, 2=Right)
1            # of broadcast
1            BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)
1            # of lookahead depth
1            DEPTHs (>=0)
2            SWAP (0=bin-exch,1=long,2=mix)
64           swapping threshold
0            L1 in (0=transposed,1=no-transposed) form
0            U  in (0=transposed,1=no-transposed) form
1            Equilibration (0=no,1=yes)
8            memory alignment in double (> 0)

</pre>
        <p>
        Save the file and exit nano.
 </p>
        <p>
Then in the bin/rpi directory run:
         </p>
    <pre>
./xhpl
</pre>
        <p>
This will produce output like:
         </p>
    <pre>
================================================================================
HPLinpack 2.2  --  High-Performance Linpack benchmark  --   February 24, 2016
Written by A. Petitet and R. Clint Whaley,  Innovative Computing Laboratory, UTK
Modified by Piotr Luszczek, Innovative Computing Laboratory, UTK
Modified by Julien Langou, University of Colorado Denver
================================================================================

An explanation of the input/output parameters follows:
T/V    : Wall time / encoded variant.
N      : The order of the coefficient matrix A.
NB     : The partitioning blocking factor.
P      : The number of process rows.
Q      : The number of process columns.
Time   : Time in seconds to solve the linear system.
Gflops : Rate of execution for solving the linear system.

The following parameter values will be used:

N      :    5040
NB     :     128
PMAP   : Row-major process mapping
P      :       1
Q      :       1
PFACT  :   Right
NBMIN  :       4
NDIV   :       2
RFACT  :   Crout
BCAST  :  1ringM
DEPTH  :       1
SWAP   : Mix (threshold = 64)
L1     : transposed form
U      : transposed form
EQUIL  : yes
ALIGN  : 8 double precision words

--------------------------------------------------------------------------------

- The matrix A is randomly generated for each test.
- The following scaled residual check will be computed:
      ||Ax-b||_oo / ( eps * ( || x ||_oo * || A ||_oo + || b ||_oo ) * N )
- The relative machine precision (eps) is taken to be               1.110223e-16
- Computational tests pass if scaled residuals are less than                16.0
    </pre>
        <p>
and this will take some time to run.
 </p>
        <p>
Then in the end it will produce output like:
 </p>
<pre>
================================================================================
T/V                N    NB     P     Q               Time                 Gflops
--------------------------------------------------------------------------------
WR11C2R4        5040   128     1     1             317.11              2.693e-01
HPL_pdgesv() start time Thu Aug 18 09:28:47 2016

HPL_pdgesv() end time   Thu Aug 18 09:34:04 2016

--------------------------------------------------------------------------------
||Ax-b||_oo/(eps*(||A||_oo*||x||_oo+||b||_oo)*N)=        0.0021492 ...... PASSED
================================================================================

Finished      1 tests with the following results:
              1 tests completed and passed residual checks,
              0 tests completed and failed residual checks,
              0 tests skipped because of illegal input values.
--------------------------------------------------------------------------------

End of Tests.
================================================================================
</pre>
        <p>
The numbers will vary but this result about shows that a single Raspberry Pi 3 achieves 269.3Mflops (see under the Gflops column at the top).
 </p>
<p>
Now what we will do is run LINPACK across our cluster.
 </p>
        <p>
The first thing you need to do is to create a hostfile with the ip addresses of your nodes.
         </p>
    <pre>
192.168.2.18:4
192.168.2.72:4
192.168.2.55:4
192.168.2.39:4
192.168.2.62:4
</pre>
        <p>
Now you will need to edit your HPL.dat:
        </p>
<pre>
HPLinpack benchmark input file
Innovative Computing Laboratory, University of Tennessee
HPL.out      output file name (if any)
6            device out (6=stdout,7=stderr,file)
1            # of problems sizes (N)
17400         Ns
1            # of NBs
128          NBs
0            PMAP process mapping (0=Row-,1=Column-major)
1            # of process grids (P x Q)
4            Ps
5            Qs
16.0         threshold
1            # of panel fact
2            PFACTs (0=left, 1=Crout, 2=Right)
1            # of recursive stopping criterium
4            NBMINs (>= 1)
1            # of panels in recursion
2            NDIVs
1            # of recursive panel fact.
1            RFACTs (0=left, 1=Crout, 2=Right)
1            # of broadcast
1            BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)
1            # of lookahead depth
1            DEPTHs (>=0)
2            SWAP (0=bin-exch,1=long,2=mix)
64           swapping threshold
0            L1 in (0=transposed,1=no-transposed) form
0            U  in (0=transposed,1=no-transposed) form
1            Equilibration (0=no,1=yes)
8            memory alignment in double (> 0)

</pre>
        <p>
Then run the program using mpiexec:
         </p>
<pre>
mpiexec -n 20 -f hostfile ./xhpl
</pre>
        <p>
This will output information like the last run just for the whole cluster.
 </p>
<p>
For my example cluster a test run came out 2.403Gflops.
 </p>
        <p>
Your speeds will vary. This is the default setup for Linpack on this cluster - we have been exploring ways of getting better performance - for example we can change some of the software libraries in the benchmark for more efficient ones, this has proven to give far better performance numbers.
 </p>
        <p>Further instructions for tweaking your cluster and installing demos from EPCC and ARCHER will be appearing in the future. Monitor our blog at <a href="https://www.epcc.ed.ac.uk/blog">https://www.epcc.ed.ac.uk/blog</a> and Twitter feed at <a href="https://twitter.com/EPCCed">https://twitter.com/EPCCed</a> for related announcements. And track this page for updates at <a href="https://epcced.github.io/wee_archlet/">Wee Archlet HTML</a> and the <a href="https://github.com/EPCCed/wee_archlet/">Git repository</a>.</p>

<p>
<b>Note:</b> If the network connections appear to break connection (error message comes up) or freeze (network becomes unresponsive), add the following line to the file /etc/sysctl.conf:
     </p>
        <pre>vm.min_free_kbytes = 16384 </pre>


    </body>
</html>
